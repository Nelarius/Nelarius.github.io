<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cpp on My thought repository</title>
    <link>https://nelari.us/tags/cpp/</link>
    <description>Recent content in cpp on My thought repository</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 16 Nov 2023 08:03:00 +0200</lastBuildDate><atom:link href="https://nelari.us/tags/cpp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Notes on C&#43;&#43; initialization</title>
      <link>https://nelari.us/post/cpp_initialization_notes/</link>
      <pubDate>Thu, 16 Nov 2023 08:03:00 +0200</pubDate>
      
      <guid>https://nelari.us/post/cpp_initialization_notes/</guid>
      <description>After getting back into hands-on programming with C++ after a long break, I reached for the shiny new way of doing aggregate initialization, called designated initializers. In two short weeks of writing code, I managed to shoot myself in the foot due to incorrect assumptions about the ways that initialization work.
I reviewed some of the details of initialization, and developed some guidelines which should hopefully help prevent some footguns in the future.</description>
    </item>
    
    <item>
      <title>GPU Pathtracer Devlog</title>
      <link>https://nelari.us/post/pathtracer_devlog/</link>
      <pubDate>Mon, 30 Oct 2023 17:19:21 +0200</pubDate>
      
      <guid>https://nelari.us/post/pathtracer_devlog/</guid>
      <description>This post is a devlog for my rayfinder project. Follow along to see the progress, starting from scratch by opening a simple window.
Deferred bounced lighting 2024-04-28
Commit: 7526265
Bounced lighting is added to the deferred render pipeline. The surfaceColor function now contains an identical diffuse sampling step as the reference path tracer. Output is identical to the reference path tracer without any accumulation.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @must_use fn surfaceColor(rng: ptr&amp;lt;function, u32&amp;gt;, primaryPos: vec3f, primaryNormal: vec3f, primaryAlbedo: vec3f) -&amp;gt; vec3f { var position = primaryPos; var normal = primaryNormal; var albedo = primaryAlbedo; var radiance = vec3(0f); var throughput = vec3(1f); radiance += throughput * lightSample(rng, position, normal, albedo); for (var bounce = 1; bounce &amp;lt; NUM_BOUNCES; bounce += 1) { let wi = evalImplicitLambertian(normal, rng); let ray = Ray(position, wi); throughput *= albedo; var hit: Intersection; if rayIntersectBvh(ray, T_MAX, &amp;amp;hit) { position = hit.</description>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Game on My thought repository</title>
    <link>http://nelari.us/tags/game/index.xml</link>
    <description>Recent content in Game on My thought repository</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://nelari.us/tags/game/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Implementing simple translation and rotation gizmos</title>
      <link>http://nelari.us/post/gizmos/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://nelari.us/post/gizmos/</guid>
      <description>

&lt;p&gt;Fed up with entering numbers manually via the UI for each game object transform in my home-made game engine, I wanted to integrate a gizmo tool. Gizmos, at least in the context of game engine editors, are little 3d tools that you can use to manipulate objects in 3d space. While there are a few easy-ish-to-integrate transform gizmo libraries on github, I was not completely happy with them. The interface of &lt;a href=&#34;https://github.com/ddiakopoulos/tinygizmo&#34;&gt;&lt;code&gt;tinygizmo&lt;/code&gt;&lt;/a&gt; is nice, but it intersects camera rays with the triangle meshes of the primitive. This means that the graphical representation of the gizmo is tied to the geometric representation which is used to test for mouse positions. &lt;a href=&#34;https://github.com/CedricGuillemet/ImGuizmo&#34;&gt;&lt;code&gt;ImGuizmo&lt;/code&gt;&lt;/a&gt; takes an easy-to-integrate approach by integrating via &lt;code&gt;ImGui&lt;/code&gt;, but exposes the transform construct as a matrix.&lt;/p&gt;

&lt;p&gt;In this post, I&amp;rsquo;ll detail the approach that I took in writing my own gizmo tool: a basic overview of how my tool works, and how to detect when the mouse is hovering over, or near, a gizmo. The code samples use my own IO and math abstractions, but they should be pretty self-explanatory.&lt;/p&gt;

&lt;h2 id=&#34;the-approach&#34;&gt;The approach&lt;/h2&gt;

&lt;p&gt;The C++ interface to the gizmo tool is very simple.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;enum class GizmoMode
{
    none,
    translate,
    rotate,
    scale
};

// The gizmo tool is active if the tool is selected (the mouse is pressed and near the tool).
// Use this to prevent e.g. the camera from moving when dragging the gizmo.
bool gizmo_is_active();

void gizmo_manipulate(GizmoMode mode, Transform&amp;amp; transform, const Mat4f&amp;amp; camera_matrix);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You pass &lt;code&gt;gizmo_manipulate&lt;/code&gt; the mode, the &lt;code&gt;Transform&lt;/code&gt; struct, and your camera matrix (the combined view and projection matrix) every frame. My transform struct looks like &lt;code&gt;struct Transform { Vec3f position; Quatf rotation; Vec3f scale; };&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The gizmo is an immediate-mode tool, so if &lt;code&gt;gizmo_manipulate&lt;/code&gt; doesn&amp;rsquo;t get called, then no manipulation happens and no tool is rendered.&lt;/p&gt;

&lt;p&gt;Every frame, we first need to generate a camera ray from the current cursor position. The ray can be constructed using the camera matrix. The pixel coordinates are first converted to the $[-1, 1]$ range in both x and y, and then the ray is taken from normalized device coordinates to world-space using the inverse of the camera matrix:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// gives mouse pixel coordinates in the [-1, 1] range
Vec2f n = platform().mouse.normalized_coordinates();

Vec4f ray_start, ray_end;
Mat4f view_proj_inverse = inverse(camera_matrix);

ray_start = view_proj_inverse * Vec4f(n.x, n.y, 0.f, 1.f);
ray_start *= 1.f / ray_start.w;

ray_end = view_proj_inverse * Vec4f(n.x, n.y, 1.f, 1.f);
ray_end *= 1.f / ray_end.w;

context.camera_ray.origin = (Vec3f&amp;amp;)ray_start;
context.camera_ray.direction = (Vec3f&amp;amp;)normalize(ray_end - ray_start);

context.camera_ray.t = FLT_MAX;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;context&lt;/code&gt; struct is just a global containing stuff used accross functions. Icky I know, but it gets the job done for a small collection of variables.&lt;/p&gt;

&lt;p&gt;Now that the camera ray has been obtained, the distance from the mouse to the gizmo can be computed. The update function proceeds as follows.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Compute the smallest distance between the ray and the gizmo, as well as the point on the gizmo which corresponds to the smallest distance. The current and previous such points are stored in the &lt;code&gt;context&lt;/code&gt; variable.&lt;/li&gt;
&lt;li&gt;If the distance to the gizmo is below some threshold value, and the mouse button was pressed, then that gizmo becomes active.&lt;/li&gt;
&lt;li&gt;If a gizmo is active, use the gizmo&amp;rsquo;s nearest point to the camera ray to update the transform.&lt;/li&gt;
&lt;li&gt;If the mouse is released, then the gizmo is deactivated.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this way, a gizmo becomes active even when the mouse is not directly over it, making the tool a bit easier to work with.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at how to compute the distance to a translation or rotation gizmo.&lt;/p&gt;

&lt;h3 id=&#34;translation&#34;&gt;Translation&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 30px; padding-top: 30px; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://drive.google.com/file/d/16RaIA8zyMselIzr_kbcoqAUcU8StgN8i/preview&#34; style=&#34;display: block; width: 100%; height: 480px;&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;The translation gizmo is visually a set of three coordinate axes. The following functions is used to test how far away the camera ray is from each individual axis.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;float closest_distance_between_lines(Rayf&amp;amp; l1, Rayf&amp;amp; l2)
{
    const Vec3f dp = l2.origin - l1.origin;
    const float v12 = dot(l1.direction, l1.direction);
    const float v22 = dot(l2.direction, l2.direction);
    const float v1v2 = dot(l1.direction, l2.direction);

    const float det = v1v2 * v1v2 - v12 * v22;

    if (std::abs(det) &amp;gt; FLT_MIN)
    {
        const float inv_det = 1.f / det;

        const float dpv1 = dot(dp, l1.direction);
        const float dpv2 = dot(dp, l2.direction);

        l1.t = inv_det * (v22 * dpv1 - v1v2 * dpv2);
        l2.t = inv_det * (v1v2 * dpv1 - v12 * dpv2);

        return norm(dp + l2.direction * l2.t - l1.direction * l1.t);
    }
    else
    {
        const Vec3f a = cross(dp, l1.direction);
        return std::sqrt(dot(a, a) / v12);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to know where the math came from, scroll further down to &lt;code&gt;Shortest distance between two lines&lt;/code&gt; section.&lt;/p&gt;

&lt;p&gt;The function returns the distance, and computes the parameter &lt;em&gt;t&lt;/em&gt; for both rays so that the points corresponding to the smallest distance can be coputed.&lt;/p&gt;

&lt;p&gt;So, given the translation gizmo, how is the &lt;code&gt;position&lt;/code&gt; component of the user&amp;rsquo;s transform manipulated? Easy, the translation gizmo gives us this frame&amp;rsquo;s and last frame&amp;rsquo;s 3d point on the gizmo axis in world space coordinates! All we have to do is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Vec3f delta = context.current_intersect - context.previous_intersect;
user_transform.position += delta;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://drive.google.com/uc?export=view&amp;amp;id=1RSrUwO93QzD8MrE-ikFT4iEb5GCEGFF0&#34; alt=&#34;translate_diagram&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;shortest-distance-between-two-lines&#34;&gt;Shortest distance between two lines&lt;/h3&gt;

&lt;p&gt;Given a line $\mathcal{L}=\mathbf{p}+t\mathbf{v}$, where $\mathbf{p}$ is a point on the line, $\mathbf{v}$ is the direction of the line, and &lt;em&gt;t&lt;/em&gt; is the scaling factor, the squared distance function between line 1 and line 2 is given by&lt;/p&gt;

&lt;div&gt;$$
d^2=(\mathcal{L}_2-\mathcal{L}_1)^2=(\mathbf{p}_2+t_2\mathbf{v}_2-\mathbf{p}_1-t_1\mathbf{v}_1)^2
$$&lt;/div&gt;

&lt;p&gt;The function will have a minimum at the shortest distance; in other words, the derivative of this function w.r.t. &lt;em&gt;t&lt;/em&gt; will be zero at the minimum. We can use this to solve for $t_1$ and $t_2$.&lt;/p&gt;

&lt;p&gt;Computing the derivates of the squared distance function w.r.t. both $t_1$ and $t_2$ gives us a system of equations.&lt;/p&gt;

&lt;div&gt;$$
\begin{cases}
\frac{\partial d^2}{\partial t_1}=2\left(\mathbf{v}_1 \cdot (\mathbf{p}_1 - \mathbf{p}_2) - t_2 \mathbf{v}_1 \cdot \mathbf{v}_2 + t_1 v_1^2 \right) = 0 \\
\frac{\partial d^2}{\partial t_2}=2\left(\mathbf{v}_2 \cdot (\mathbf{p}_2 - \mathbf{p}_1) - t_1 \mathbf{v}_1 \cdot \mathbf{v}_2 + t_2 v_2^2\right) = 0
\end{cases}
$$&lt;/div&gt;

&lt;p&gt;The system of equations can be expressed in matrix form.&lt;/p&gt;

&lt;div&gt;$$
\begin{bmatrix} v_1^2 &amp; - \mathbf{v}_1 \cdot \mathbf{v}_2 \\ - \mathbf{v}_1 \cdot \mathbf{v}_2 &amp; v_2^2 \end{bmatrix}
\begin{bmatrix} t_1 \\ t_2 \end{bmatrix}
=
\begin{bmatrix} \mathbf{v}_1 \cdot (\mathbf{p}_2 - \mathbf{p}_1) \\ \mathbf{v}_2 \cdot (\mathbf{p}_1 - \mathbf{p}_2) \end{bmatrix}
$$&lt;/div&gt;

&lt;p&gt;Solving the matrix equation is easy, because the inverse of 2x2 matrix can be &lt;a href=&#34;https://en.wikipedia.org/wiki/Invertible_matrix#Inversion_of_2_%C3%97_2_matrices&#34;&gt;looked up&lt;/a&gt; and yields us the following equation.&lt;/p&gt;

&lt;div&gt;$$
\begin{bmatrix} t_1 \\ t_2 \end{bmatrix}
=
\frac{1}{v_1^2 v_2^2 - (\mathbf{v}_1 \cdot \mathbf{v}_2)^2}
\begin{bmatrix} v_2^2 &amp; \mathbf{v}_1 \cdot \mathbf{v}_2 \\ \mathbf{v}_1 \cdot \mathbf{v}_2 &amp; v_1^2 \end{bmatrix}
\begin{bmatrix} \mathbf{v}_1 \cdot (\mathbf{p}_2 - \mathbf{p}_1) \\ \mathbf{v}_2 \cdot (\mathbf{p}_1 - \mathbf{p}_2) \end{bmatrix}
$$&lt;/div&gt;

&lt;p&gt;This equation is the one used in the function &lt;code&gt;closest_distance_between_lines&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When the two lines are parallel, the determinant $v_1^2 v_2^2 - (\mathbf{v}_1 \cdot \mathbf{v}_2)^2$ is zero. In that case, we just compute the perpendicular distance between points $\mathbf{p}_1$ and $\mathbf{p}_2$.&lt;/p&gt;

&lt;h3 id=&#34;rotation&#34;&gt;Rotation&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 30px; padding-top: 30px; overflow: hidden;&#34;&gt;
    &lt;iframe src=&#34;https://drive.google.com/file/d/1cI6gIWm46-Zrtbw5CpSRdXgNP5jvP59a/preview&#34; style=&#34;display: block; width: 100%; height: 480px;&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;The rotation gizmo is visually a set of three circles, each one centered around an axis of rotation. The following function can be used to get the point on the circle nearest to the camera ray.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;float closest_distance_line_circle(const Ray&amp;amp; line, const Circle&amp;amp; c, Vec3f&amp;amp; point)
{
    plane f = make_plane(c.orientation, c.center);
    ray r = line;

    if (intersect_ray_plane(f, r))
    {
        // get the ray&#39;s intersection point on the plane which
        // contains the circle
        const Vec3f on_plane = r.origin + r.t * r.direction;
        // project that point on to the circle&#39;s circumference
        point = c.center + c.radius * normalize(on_plane - c.center);
        return norm(on_plane - point);
    }
    else
    {
        // the required point on the circle is the one closest to the camera origin
        point = c.radius * normalize(reject(context.camera_ray.origin - c.center, c.orientation));

        return distance_between_point_ray(point, context.camera_ray);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to compute the rotation during the frame, the current and previous points on the circle are again used. By subtracting the circle&amp;rsquo;s center from them, two direction vectors are obtained. The angle between the direction vectors represents the rotation made during the frame.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://drive.google.com/uc?export=view&amp;amp;id=1HqImj_sm2A8fhPyZ0scDfL1VPSEOAXR0&#34; alt=&#34;rotate_diagram&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The angle between the two direction vectors is always positive when computing via the dot product. The sign should change if the previous and current points were to change position, or the gizmo would rotate in the same direction no matter which direction the user is dragging the mouse. The sign can be obtained by calculating
&lt;div&gt;$$
sign = \frac{\left(\mathbf{p}_p \times \mathbf{p}_c\right) \cdot \hat{\mathbf{n}}}{||\left(\mathbf{p}_p \times \mathbf{p}_c\right) \cdot \hat{\mathbf{n}}||}\,,
$$&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;using the vectors identified in the above diagram.&lt;/p&gt;

&lt;h3 id=&#34;rendering-the-gizmos&#34;&gt;Rendering the gizmos&lt;/h3&gt;

&lt;p&gt;The gizmos are currently rendered by simply drawing lines via OpenGL. I used my engine&amp;rsquo;s debug draw API for that, since it has functions for drawing primitives such as lines and circles in immediate mode. The rendering code for e.g. the translation gizmo ends up being&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void draw_translation_gizmo(const Transform&amp;amp; transform)
{
    for (int i = axis_x; i &amp;lt; axis_count; i++)
    {
        Vec3f axis_end = Vec3f(0.f, 0.f, 0.f);
        axis_end[i] = 1.f;

        vec3f axis_color = Vec3f(0.f, 0.f, 0.f);
        axis_color[i] = 1.f;

        if (i == context.selected_axis)
        {
            axis_color = Vec3f(1.f, 0.65f, 0.f);
        }

        debug_draw_add_line(transform.position, axis_end + transform.position, axis_color);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, the gizmos could be rendered as a 3d mesh as well, since the representation of the gizmo has nothing to do with its interaction.&lt;/p&gt;

&lt;p&gt;The scale gizmo hasn&amp;rsquo;t been covered in this post. The main reason being that I haven&amp;rsquo;t needed to scale game objects so far. As a result, I simply duplicated the functionality for the translation tool for the scale tool so that you can scale an object by clicking and dragging the axes.&lt;/p&gt;

&lt;p&gt;And there you have it!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>My thought repository</title>
    <link>http://nelari.us/index.xml</link>
    <description>Recent content on My thought repository</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 23 Dec 2017 16:17:29 +0200</lastBuildDate>
    <atom:link href="http://nelari.us/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Implementing simple translation and rotation gizmos</title>
      <link>http://nelari.us/post/gizmos/</link>
      <pubDate>Sat, 23 Dec 2017 16:17:29 +0200</pubDate>
      
      <guid>http://nelari.us/post/gizmos/</guid>
      <description>

&lt;p&gt;Fed up with entering numbers manually via the UI for each game object transform in my home-made game engine, I wanted to integrate a gizmo tool. Gizmos, at least in the context of game engine editors, are little 3d tools that you can use to manipulate objects in 3d space. While there are a few easy-ish-to-integrate transform gizmo libraries on github, I was not completely happy with them. The interface of &lt;a href=&#34;https://github.com/ddiakopoulos/tinygizmo&#34;&gt;&lt;code&gt;tinygizmo&lt;/code&gt;&lt;/a&gt; is nice, but it intersects camera rays with the triangle meshes of the primitive. This means that the graphical representation of the gizmo is tied to the geometric representation which is used to test for mouse positions. &lt;a href=&#34;https://github.com/CedricGuillemet/ImGuizmo&#34;&gt;&lt;code&gt;ImGuizmo&lt;/code&gt;&lt;/a&gt; takes an easy-to-integrate approach by integrating via &lt;code&gt;ImGui&lt;/code&gt;, but exposes the transform construct as a matrix.&lt;/p&gt;

&lt;p&gt;In this post, I&amp;rsquo;ll detail the approach that I took in writing my own gizmo tool: a basic overview of how my tool works, and how to detect when the mouse is hovering over, or near, a gizmo. The code samples use my own IO and math abstractions, but they should be pretty self-explanatory.&lt;/p&gt;

&lt;h2 id=&#34;the-approach&#34;&gt;The approach&lt;/h2&gt;

&lt;p&gt;The C++ interface to the gizmo tool is very simple.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;enum class GizmoMode
{
    none,
    translate,
    rotate,
    scale
};

// The gizmo tool is active if the tool is selected (the mouse is pressed and near the tool).
// Use this to prevent e.g. the camera from moving when dragging the gizmo.
bool gizmo_is_active();

void gizmo_manipulate(GizmoMode mode, Transform&amp;amp; transform, const Mat4f&amp;amp; camera_matrix);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You pass &lt;code&gt;gizmo_manipulate&lt;/code&gt; the mode, the &lt;code&gt;Transform&lt;/code&gt; struct, and your camera matrix (the combined view and projection matrix) every frame. My transform struct looks like &lt;code&gt;struct Transform { Vec3f position; Quatf rotation; Vec3f scale; };&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The gizmo is an immediate-mode tool, so if &lt;code&gt;gizmo_manipulate&lt;/code&gt; doesn&amp;rsquo;t get called, then no manipulation happens and no tool is rendered.&lt;/p&gt;

&lt;p&gt;Every frame, we first need to generate a camera ray from the current cursor position. The ray can be constructed using the camera matrix. The pixel coordinates are first converted to the $[-1, 1]$ range in both x and y, and then the ray is taken from normalized device coordinates to world-space using the inverse of the camera matrix:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// gives mouse pixel coordinates in the [-1, 1] range
Vec2f n = platform().mouse.normalized_coordinates();

Vec4f ray_start, ray_end;
Mat4f view_proj_inverse = inverse(camera_matrix);

ray_start = view_proj_inverse * Vec4f(n.x, n.y, 0.f, 1.f);
ray_start *= 1.f / ray_start.w;

ray_end = view_proj_inverse * Vec4f(n.x, n.y, 1.f, 1.f);
ray_end *= 1.f / ray_end.w;

context.camera_ray.origin = (Vec3f&amp;amp;)ray_start;
context.camera_ray.direction = (Vec3f&amp;amp;)normalize(ray_end - ray_start);

context.camera_ray.t = FLT_MAX;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;context&lt;/code&gt; struct is just a global containing stuff used accross functions. Icky I know, but it gets the job done for a small collection of variables.&lt;/p&gt;

&lt;p&gt;Now that the camera ray has been obtained, the distance from the mouse to the gizmo can be computed. The update function proceeds as follows.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Compute the smallest distance between the ray and the gizmo, as well as the point on the gizmo which corresponds to the smallest distance. The current and previous such points are stored in the &lt;code&gt;context&lt;/code&gt; variable.&lt;/li&gt;
&lt;li&gt;If the distance to the gizmo is below some threshold value, and the mouse button was pressed, then that gizmo becomes active.&lt;/li&gt;
&lt;li&gt;If a gizmo is active, use the gizmo&amp;rsquo;s nearest point to the camera ray to update the transform.&lt;/li&gt;
&lt;li&gt;If the mouse is released, then the gizmo is deactivated.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In this way, a gizmo becomes active even when the mouse is not directly over it, making the tool a bit easier to work with.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take a look at how to compute the distance to a translation or rotation gizmo.&lt;/p&gt;

&lt;h3 id=&#34;translation&#34;&gt;Translation&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 30px; padding-top: 30px; overflow: hidden;&#34;&gt;
  &lt;iframe src=&#34;https://drive.google.com/file/d/16RaIA8zyMselIzr_kbcoqAUcU8StgN8i/preview&#34; style=&#34;display: block; width: 100%; height: 480px;&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;The translation gizmo is visually a set of three coordinate axes. The following functions is used to test how far away the camera ray is from each individual axis.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;float closest_distance_between_lines(Rayf&amp;amp; l1, Rayf&amp;amp; l2)
{
    const Vec3f dp = l2.origin - l1.origin;
    const float v12 = dot(l1.direction, l1.direction);
    const float v22 = dot(l2.direction, l2.direction);
    const float v1v2 = dot(l1.direction, l2.direction);

    const float det = v1v2 * v1v2 - v12 * v22;

    if (std::abs(det) &amp;gt; FLT_MIN)
    {
        const float inv_det = 1.f / det;

        const float dpv1 = dot(dp, l1.direction);
        const float dpv2 = dot(dp, l2.direction);

        l1.t = inv_det * (v22 * dpv1 - v1v2 * dpv2);
        l2.t = inv_det * (v1v2 * dpv1 - v12 * dpv2);

        return norm(dp + l2.direction * l2.t - l1.direction * l1.t);
    }
    else
    {
        const Vec3f a = cross(dp, l1.direction);
        return std::sqrt(dot(a, a) / v12);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to know where the math came from, scroll further down to &lt;code&gt;Shortest distance between two lines&lt;/code&gt; section.&lt;/p&gt;

&lt;p&gt;The function returns the distance, and computes the parameter &lt;em&gt;t&lt;/em&gt; for both rays so that the points corresponding to the smallest distance can be coputed.&lt;/p&gt;

&lt;p&gt;So, given the translation gizmo, how is the &lt;code&gt;position&lt;/code&gt; component of the user&amp;rsquo;s transform manipulated? Easy, the translation gizmo gives us this frame&amp;rsquo;s and last frame&amp;rsquo;s 3d point on the gizmo axis in world space coordinates! All we have to do is&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Vec3f delta = context.current_intersect - context.previous_intersect;
user_transform.position += delta;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;https://drive.google.com/uc?export=view&amp;amp;id=1RSrUwO93QzD8MrE-ikFT4iEb5GCEGFF0&#34; alt=&#34;translate_diagram&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;shortest-distance-between-two-lines&#34;&gt;Shortest distance between two lines&lt;/h3&gt;

&lt;p&gt;Given a line $\mathcal{L}=\mathbf{p}+t\mathbf{v}$, where $\mathbf{p}$ is a point on the line, $\mathbf{v}$ is the direction of the line, and &lt;em&gt;t&lt;/em&gt; is the scaling factor, the squared distance function between line 1 and line 2 is given by&lt;/p&gt;

&lt;div&gt;$$
d^2=(\mathcal{L}_2-\mathcal{L}_1)^2=(\mathbf{p}_2+t_2\mathbf{v}_2-\mathbf{p}_1-t_1\mathbf{v}_1)^2
$$&lt;/div&gt;

&lt;p&gt;The function will have a minimum at the shortest distance; in other words, the derivative of this function w.r.t. &lt;em&gt;t&lt;/em&gt; will be zero at the minimum. We can use this to solve for $t_1$ and $t_2$.&lt;/p&gt;

&lt;p&gt;Computing the derivates of the squared distance function w.r.t. both $t_1$ and $t_2$ gives us a system of equations.&lt;/p&gt;

&lt;div&gt;$$
\begin{cases}
\frac{\partial d^2}{\partial t_1}=2\left(\mathbf{v}_1 \cdot (\mathbf{p}_1 - \mathbf{p}_2) - t_2 \mathbf{v}_1 \cdot \mathbf{v}_2 + t_1 v_1^2 \right) = 0 \\
\frac{\partial d^2}{\partial t_2}=2\left(\mathbf{v}_2 \cdot (\mathbf{p}_2 - \mathbf{p}_1) - t_1 \mathbf{v}_1 \cdot \mathbf{v}_2 + t_2 v_2^2\right) = 0
\end{cases}
$$&lt;/div&gt;

&lt;p&gt;The system of equations can be expressed in matrix form.&lt;/p&gt;

&lt;div&gt;$$
\begin{bmatrix} v_1^2 &amp; - \mathbf{v}_1 \cdot \mathbf{v}_2 \\ - \mathbf{v}_1 \cdot \mathbf{v}_2 &amp; v_2^2 \end{bmatrix}
\begin{bmatrix} t_1 \\ t_2 \end{bmatrix}
=
\begin{bmatrix} \mathbf{v}_1 \cdot (\mathbf{p}_2 - \mathbf{p}_1) \\ \mathbf{v}_2 \cdot (\mathbf{p}_1 - \mathbf{p}_2) \end{bmatrix}
$$&lt;/div&gt;

&lt;p&gt;Solving the matrix equation is easy, because the inverse of 2x2 matrix can be &lt;a href=&#34;https://en.wikipedia.org/wiki/Invertible_matrix#Inversion_of_2_%C3%97_2_matrices&#34;&gt;looked up&lt;/a&gt; and yields us the following equation.&lt;/p&gt;

&lt;div&gt;$$
\begin{bmatrix} t_1 \\ t_2 \end{bmatrix}
=
\frac{1}{v_1^2 v_2^2 - (\mathbf{v}_1 \cdot \mathbf{v}_2)^2}
\begin{bmatrix} v_2^2 &amp; \mathbf{v}_1 \cdot \mathbf{v}_2 \\ \mathbf{v}_1 \cdot \mathbf{v}_2 &amp; v_1^2 \end{bmatrix}
\begin{bmatrix} \mathbf{v}_1 \cdot (\mathbf{p}_2 - \mathbf{p}_1) \\ \mathbf{v}_2 \cdot (\mathbf{p}_1 - \mathbf{p}_2) \end{bmatrix}
$$&lt;/div&gt;

&lt;p&gt;This equation is the one used in the function &lt;code&gt;closest_distance_between_lines&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;When the two lines are parallel, the determinant $v_1^2 v_2^2 - (\mathbf{v}_1 \cdot \mathbf{v}_2)^2$ is zero. In that case, we just compute the perpendicular distance between points $\mathbf{p}_1$ and $\mathbf{p}_2$.&lt;/p&gt;

&lt;h3 id=&#34;rotation&#34;&gt;Rotation&lt;/h3&gt;

&lt;div style=&#34;position: relative; padding-bottom: 30px; padding-top: 30px; overflow: hidden;&#34;&gt;
    &lt;iframe src=&#34;https://drive.google.com/file/d/1cI6gIWm46-Zrtbw5CpSRdXgNP5jvP59a/preview&#34; style=&#34;display: block; width: 100%; height: 480px;&#34; webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;The rotation gizmo is visually a set of three circles, each one centered around an axis of rotation. The following function can be used to get the point on the circle nearest to the camera ray.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;float closest_distance_line_circle(const Ray&amp;amp; line, const Circle&amp;amp; c, Vec3f&amp;amp; point)
{
    plane f = make_plane(c.orientation, c.center);
    ray r = line;

    if (intersect_ray_plane(f, r))
    {
        // get the ray&#39;s intersection point on the plane which
        // contains the circle
        const Vec3f on_plane = r.origin + r.t * r.direction;
        // project that point on to the circle&#39;s circumference
        point = c.center + c.radius * normalize(on_plane - c.center);
        return norm(on_plane - point);
    }
    else
    {
        // the required point on the circle is the one closest to the camera origin
        point = c.radius * normalize(reject(context.camera_ray.origin - c.center, c.orientation));

        return distance_between_point_ray(point, context.camera_ray);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to compute the rotation during the frame, the current and previous points on the circle are again used. By subtracting the circle&amp;rsquo;s center from them, two direction vectors are obtained. The angle between the direction vectors represents the rotation made during the frame.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://drive.google.com/uc?export=view&amp;amp;id=1HqImj_sm2A8fhPyZ0scDfL1VPSEOAXR0&#34; alt=&#34;rotate_diagram&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The angle between the two direction vectors is always positive when computing via the dot product. The sign should change if the previous and current points were to change position, or the gizmo would rotate in the same direction no matter which direction the user is dragging the mouse. The sign can be obtained by calculating
&lt;div&gt;$$
sign = \frac{\left(\mathbf{p}_p \times \mathbf{p}_c\right) \cdot \hat{\mathbf{n}}}{||\left(\mathbf{p}_p \times \mathbf{p}_c\right) \cdot \hat{\mathbf{n}}||}\,,
$$&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;using the vectors identified in the above diagram.&lt;/p&gt;

&lt;h3 id=&#34;rendering-the-gizmos&#34;&gt;Rendering the gizmos&lt;/h3&gt;

&lt;p&gt;The gizmos are currently rendered by simply drawing lines via OpenGL. I used my engine&amp;rsquo;s debug draw API for that, since it has functions for drawing primitives such as lines and circles in immediate mode. The rendering code for e.g. the translation gizmo ends up being&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void draw_translation_gizmo(const Transform&amp;amp; transform)
{
    for (int i = axis_x; i &amp;lt; axis_count; i++)
    {
        Vec3f axis_end = Vec3f(0.f, 0.f, 0.f);
        axis_end[i] = 1.f;

        vec3f axis_color = Vec3f(0.f, 0.f, 0.f);
        axis_color[i] = 1.f;

        if (i == context.selected_axis)
        {
            axis_color = Vec3f(1.f, 0.65f, 0.f);
        }

        debug_draw_add_line(transform.position, axis_end + transform.position, axis_color);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, the gizmos could be rendered as a 3d mesh as well, since the representation of the gizmo has nothing to do with its interaction.&lt;/p&gt;

&lt;p&gt;The scale gizmo hasn&amp;rsquo;t been covered in this post. The main reason being that I haven&amp;rsquo;t needed to scale game objects so far. As a result, I simply duplicated the functionality for the translation tool for the scale tool so that you can scale an object by clicking and dragging the axes.&lt;/p&gt;

&lt;p&gt;And there you have it!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>About me</title>
      <link>http://nelari.us/about/</link>
      <pubDate>Sun, 26 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>http://nelari.us/about/</guid>
      <description>&lt;p&gt;Hi there! My name is Johann.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m a programmer at &lt;a href=&#34;http://umbra3d.com&#34;&gt;Umbra&lt;/a&gt;. I originally studied theoretical physics with an emphasis on scientific computing and obtained my Master&amp;rsquo;s degree in 2015.&lt;/p&gt;

&lt;p&gt;I enjoy writing all kinds of software, but I usually gravitate towards writing graphics/system stuff in C++.&lt;/p&gt;

&lt;p&gt;When I&amp;rsquo;m not in front of the computer, I&amp;rsquo;m outside, riding this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://i.imgur.com/3uCtC8l.jpg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;My biggest cycling achievement so far is completing the 217 km Pirkan Pyöräily Gran Fondo, 2015 edition. I didn&amp;rsquo;t place very well, but I finished the longest bike ride of my life so far.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Projects</title>
      <link>http://nelari.us/projects/</link>
      <pubDate>Mon, 01 Aug 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nelari.us/projects/</guid>
      <description>

&lt;p&gt;Here is an overview of some of the software projects I&amp;rsquo;ve worked on in my free time.&lt;/p&gt;

&lt;h2 id=&#34;wren&#34;&gt;Wren++&lt;/h2&gt;

&lt;p&gt;A C++ binding generator for the &lt;a href=&#34;http://wren.io&#34;&gt;Wren programming language&lt;/a&gt;. It utilizes modern C++14 metaprogramming features and is fairly compact as a result. You can use Wren++ to wrap any C++ function or class in Wren code. Wren++ also provides access to Wren code from C++.&lt;/p&gt;

&lt;p&gt;I wrote a small tutorial on its usage on my &lt;a href=&#34;http://nelari.us/post/wren-embedding-2/&#34;&gt;blog&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Find it on &lt;a href=&#34;https://github.com/Nelarius/wrenpp&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;vscode-wren&#34;&gt;vscode-wren&lt;/h2&gt;

&lt;p&gt;A Visual Studio Code extension for the Wren programming language. Currently the extension provides snippets and syntax highlighting for most language features.&lt;/p&gt;

&lt;p&gt;Find it on &lt;a href=&#34;https://github.com/Nelarius/vscode-wren&#34;&gt;github&lt;/a&gt; and the vscode &lt;a href=&#34;https://marketplace.visualstudio.com/items?itemName=nelarius.vscode-wren&#34;&gt;marketplace&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/Nelarius/vscode-wren/master/images/syntax-highlighting.png?token=ADH_jKJ5SJcQi5Rp3pUv6DtkvqlAmMfPks5XboouwA%3D%3D&#34; alt=&#34;Syntax highlighting&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;secon&#34;&gt;secon&lt;/h2&gt;

&lt;p&gt;An agent-based economy simulation that I wrote in Lua, based on the work of &lt;a href=&#34;http://www.cs.princeton.edu/~ken/scott.pdf&#34;&gt;Steiglitz, Honig, and Cohen&lt;/a&gt; and &lt;a href=&#34;http://larc.unt.edu/techreports/LARC-2010-03.pdf&#34;&gt;Doran and Parberry&lt;/a&gt;. The goal was to simulate the law of supply and demand for a variety of commodities and see if I could create price hikes via artificial shortages.&lt;/p&gt;

&lt;p&gt;Find it on &lt;a href=&#34;https://github.com/Nelarius/secon&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Embedding Wren in C&#43;&#43;, part 2</title>
      <link>http://nelari.us/post/wren-embedding-2/</link>
      <pubDate>Fri, 06 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nelari.us/post/wren-embedding-2/</guid>
      <description>

&lt;p&gt;You can read part 1 &lt;a href=&#34;http://nelari.us/post/wren-embedding-1/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Writing you own Wren bindings gives you full control over how your code interfaces with Wren. However, manually implementing the binding code for a large C++-Wren interface can be somewhat time consuming, especially when changes are made to the interface over time. &lt;a href=&#34;https://github.com/nelarius/wrenpp&#34;&gt;Wren++&lt;/a&gt; is a small C++ library that aims to automate most code binding tasks with a minimal runtime overhead. Like Wren itself, Wren++ aims to be simple and minimalistic to use. Here are the features currently supported.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a RAII wrapper class for the virtual machine instance and refcounted methods&lt;/li&gt;
&lt;li&gt;automatic binding code generation for any C++ type and method&lt;/li&gt;
&lt;li&gt;a convenient way of calling methods from C++ and accessing return values&lt;/li&gt;
&lt;li&gt;template-based &amp;ndash; no macros! If you feel like the binding code in Wren++ is too verbose, you can roll your own macros.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The easiest way to get started with Wren++ is simply to include the source code in your project. Just remember to compile with C++14 features turned on! Alternatively, you can use the included premake script to generate a Makefile or project file for your preferred IDE to generate a static library to link to. In order to use Wren++, include &lt;code&gt;Wren++.h&lt;/code&gt; in your code. You also need to link to the Wren static library.&lt;/p&gt;

&lt;h3 id=&#34;creating-a-vm-instance&#34;&gt;Creating a VM instance&lt;/h3&gt;

&lt;p&gt;Wren++ provides reasonable defaults for the virtual machine configuration. To get started, just write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;Wren++.h&amp;gt;

int main() {
  wrenpp::VM vm;
  wrenpp::Result result = vm.executeString(&amp;quot;System.print(\&amp;quot;Hello, world\&amp;quot;)&amp;quot;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like the Wren C API itself, Wren++ provides the interpretation result as an enumeration class. The values are &lt;code&gt;Success&lt;/code&gt;, &lt;code&gt;CompileError&lt;/code&gt;, and &lt;code&gt;RuntimeError&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can also execute code directly from a module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto result = vm.executeModule(&amp;quot;vector&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;module-class-contexts-and-binding-free-functions-to-wren&#34;&gt;Module, class contexts and binding free functions to Wren&lt;/h3&gt;

&lt;p&gt;All method binding takes place in a module and class context. The binding methods return references back to the class context so that you can chain binding commands like in LuaBridge or Luabind. Let&amp;rsquo;s look at binding functions to the &lt;code&gt;Math&lt;/code&gt; class that we did earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wrenpp::beginModule(&amp;quot;main&amp;quot;)
  .beginClass(&amp;quot;Math&amp;quot;)
    .bindFunction&amp;lt;decltype(&amp;amp;cos), &amp;amp;cos&amp;gt;(true, &amp;quot;cos(_)&amp;quot;)
    .bindFunction&amp;lt;decltype(&amp;amp;sin), &amp;amp;sin&amp;gt;(true, &amp;quot;sin(_)&amp;quot;)
  .endClass()
.endModule();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bindFunction&lt;/code&gt; takes two template parameters and two function arguments. The template parameters are the declared type of the function, and then the function pointer value itself. Instead of writing &lt;code&gt;decltype(&amp;amp;cos)&lt;/code&gt;, we could have written &lt;code&gt;double(*)(double)&lt;/code&gt;. As for the function arguments, the boolean indicates whether the method is static, and the string is the method&amp;rsquo;s signature.&lt;/p&gt;

&lt;p&gt;It is entirely optional to include &lt;code&gt;endClass()&lt;/code&gt; and &lt;code&gt;endModule()&lt;/code&gt; at the end of the binding statement. &lt;code&gt;endClass()&lt;/code&gt; returns a reference back to the enclosing module context, so that you can continue binding code to a new class without having to open the context again. Not all binding statements have to be in the same place. You can reopen the module and class contexts somewhere else and continue binding code. All that the module and class contexts do is store the module and class names for binding method to use.&lt;/p&gt;

&lt;h3 id=&#34;binding-types-and-methods-to-wren&#34;&gt;Binding types and methods to Wren&lt;/h3&gt;

&lt;p&gt;Binding types and their methods works very similarly. Let&amp;rsquo;s look at rebinding the &lt;code&gt;Vec3f&lt;/code&gt; example from earlier. When binding a type, we use a different class context. It&amp;rsquo;s created using the template method &lt;code&gt;bindClass&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wrenpp::beginModule(&amp;quot;Vec3&amp;quot;)
  .bindClass&amp;lt;Vec3f, float, float, float&amp;gt;(&amp;quot;Vec3&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bindClass&lt;/code&gt; tells Wren++ not only to store the name of the class for future reference, but also to generate the allocator and finalizer functions for the given type. The first template parameter is the type of bound class. The following template parameters are optional &amp;ndash; they are the values that can be passed to the bound type&amp;rsquo;s constructor from Wren. The three floats in this example mean that we can construct the type from Wren using three numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;foreign class Vec3 {
  construct new(x, y, z) {}
  // the rest of the methods as before
}

// now we can construct with values
var v = Vec3.new(2.0, 1.0, -3.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even though we can bind to overloaded methods in Wren, we can bind only one constructor to a class.&lt;/p&gt;

&lt;p&gt;Binding the rest of &lt;code&gt;Vec3f&lt;/code&gt;&amp;rsquo;s methods is done using &lt;code&gt;bindMethod&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wrenpp::beginModule(&amp;quot;Vec3&amp;quot;)
  .bindClass&amp;lt;Vec3f, float, float, float&amp;gt;(&amp;quot;Vec3&amp;quot;)
    .bindMethod&amp;lt;decltype(&amp;amp;Ve3f::norm),   &amp;amp;Vec3f::norm&amp;gt;(false, &amp;quot;norm()&amp;quot;)
    .bindMethod&amp;lt;decltype(&amp;amp;Vec3f::dot),   &amp;amp;Vec3f::dot&amp;gt;(false, &amp;quot;dot(_)&amp;quot;)
    .bindMethod&amp;lt;decltype(&amp;amp;Vec3f::cross), &amp;amp;Vec3f::cross&amp;gt;(false, &amp;quot;cross(_)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function arguments have the same meaning as for &lt;code&gt;bindFunction&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, let&amp;rsquo;s bind the accessors for the fields themselves:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  .bindGetter&amp;lt;decltype(Vec3::x), &amp;amp;Vec3::x&amp;gt;(&amp;quot;x&amp;quot;)
  .bindSetter&amp;lt;decltype(Vec3::x), &amp;amp;Vec3::x&amp;gt;(&amp;quot;x=(_)&amp;quot;)
  .bindGetter&amp;lt;decltype(Vec3::y), &amp;amp;Vec3::y&amp;gt;(&amp;quot;y&amp;quot;)
  .bindSetter&amp;lt;decltype(Vec3::y), &amp;amp;Vec3::y&amp;gt;(&amp;quot;y=(_)&amp;quot;)
  .bindGetter&amp;lt;decltype(Vec3::z), &amp;amp;Vec3::z&amp;gt;(&amp;quot;z&amp;quot;)
  .bindSetter&amp;lt;decltype(Vec3::z), &amp;amp;Vec3::z&amp;gt;(&amp;quot;z=(_)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The getters and setters are always non-static.&lt;/p&gt;

&lt;h3 id=&#34;c-and-wren-lifetimes-for-returned-objects&#34;&gt;C++ and Wren lifetimes for returned objects&lt;/h3&gt;

&lt;p&gt;The rules for who owns the returned objects are simple. Objects which are returned from C++ by reference or by pointer have C++ lifetime, and will not be garbage collected by Wren. Objects which are returned from C++ by value have Wren lifetime and are thus garbage collected.&lt;/p&gt;

&lt;h3 id=&#34;binding-your-own-implementations&#34;&gt;Binding your own implementations&lt;/h3&gt;

&lt;p&gt;Sometimes the calling convention of a C++ API is just not very amenable for binding to Wren, and you want to write your own glue code. For instance, pointers to primitive types like &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt; might be passed to a function. Wren++ simply won&amp;rsquo;t handle function signatures like that, since Wren itself has no concept of out parameters. Instead, Wren++ allows you to bind functions of type &lt;code&gt;WrenForeignMethodFn&lt;/code&gt; directly, so that you may manually implement the foreign function implementation.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at binding the excellent &lt;a href=&#34;https://github.com/ocornut/imgui&#34;&gt;dear imgui&lt;/a&gt; library to Wren. Looking at &lt;code&gt;imgui.h&lt;/code&gt;, you can see lots of long function signatures with pointers to primitive types. We want to provide reasonable default arguments to most of the arguments, as well as return the new values, instead of passing in a reference to the number. Here&amp;rsquo;s the bare-bones Wren-interface we want to implement:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;in a file called imgui.wren

class ImGui {
  foreign static begin( name )
  foreign static end()
  
  // unlike what C++ ImGui does, this RETURNS the new value
  // arguments are all numbers passed by value
  foreign static sliderFloat( label, value, min, max )
  foreign static setWindowSize( size )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s implement wrappers for &lt;code&gt;ImGui::Begin&lt;/code&gt; and &lt;code&gt;ImGui::SliderFloat&lt;/code&gt; with reasonable default values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void begin(WrenVM* vm) {
  ImGui::Begin((const char*)wrenGetSlotString(vm, 1), NULL, 0);
}

void sliderFloat(WrenVM* vm) {
  const char* label = wrenGetSlotString(vm, 1);
  float value = float(wrenGetSlotDouble(vm, 2));
  float min =   float(wrenGetSlotDouble(vm, 3));
  float max =   float(wrenGetSlotDouble(vm, 4));
  ImGui::SliderFloat(label, &amp;amp;value, min, max);
  wrenSetSlotDouble(vm, 0, value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;sliderFloat&lt;/code&gt; functions satisfy the &lt;code&gt;WrenForeignMethodFn&lt;/code&gt; typedef, so we will bind them using the &lt;code&gt;bindCFunction&lt;/code&gt; method. The &lt;code&gt;bindCFunction&lt;/code&gt; method stores the function pointer without generating any calls to the Wren slot API, so that you can do it yourself.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wrenpp::beginModule(&amp;quot;imgui&amp;quot;)
  .beginClass(&amp;quot;ImGui&amp;quot;)
    .bindCFunction(true, &amp;quot;begin(_)&amp;quot;, begin)
    .bindFunction&amp;lt;decltype(&amp;amp;ImGui::End), &amp;amp;ImGui::End&amp;gt;(true, &amp;quot;end()&amp;quot;)
    .bindCFunction(true, &amp;quot;sliderFloat(_,_,_,_)&amp;quot;, sliderFloat)
  .endClass();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we just bound &lt;code&gt;ImGui::End&lt;/code&gt; the usual way since it had a trivial function signature!&lt;/p&gt;

&lt;h4 id=&#34;accessing-foreign-bytes-manually&#34;&gt;Accessing foreign bytes manually&lt;/h4&gt;

&lt;p&gt;Next off, how do we deal with foreign types in our manual foreign method implementations? You can&amp;rsquo;t get the pointer to your foreign type just by using &lt;code&gt;wrenGetSlotForeign&lt;/code&gt;, since Wren++ contains a layer of indirection. The object may live in C++ (C++ lifetime), or within the foreign bytes (Wren lifetime) themselves. Wren++ provides a helper function: &lt;code&gt;wrenpp::getSlotForeign&amp;lt;class T&amp;gt;(WrenVM* vm, int slot)&lt;/code&gt;. To see how it&amp;rsquo;s used, let&amp;rsquo;s wrap &lt;code&gt;ImGui::SetNextWindowSize(const ImVec2&amp;amp;)&lt;/code&gt; for our Wren interface to use. Let&amp;rsquo;s assume that you&amp;rsquo;ve bound &lt;code&gt;ImGui::ImVec2&lt;/code&gt; to Wren &amp;ndash; it&amp;rsquo;s just a simple struct: &lt;code&gt;struct ImVec2 { float x, y; };&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void setWindowSize(WrenVM* vm) {
  ImGui::SetNextWindowSize(*(wrenpp::getSlotForeign&amp;lt;ImVec2&amp;gt;(vm, 1)));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;returning-foreign-types-manually&#34;&gt;Returning foreign types manually&lt;/h4&gt;

&lt;p&gt;You can return values from your manual implementations as well. To see how, let&amp;rsquo;s look at one final slightly contrived example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class Mouse {
  // returns a Vec2
  foreign static coordinates
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will implement it using our hypothetical &lt;code&gt;MouseDevice&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// the mouse device
class MouseDevice {
public:
  static MouseDevice* get();
  const Vec2i&amp;amp; coordinates() const;
};

// elsewhere, in the CFunction implementation...
void getMouseCoordinates(WrenVM* vm) {
  Vec2i coords = MouseDevice::get()-&amp;gt;coordinates();
  wrenpp::setSlotForeignValue&amp;lt;Vec2i&amp;gt;(vm, 0, coords);
}

// we will skip over the binding code itself, as you&#39;ve now seen it a few times
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that, as the function&amp;rsquo;s name indices, &lt;code&gt;setSlotForeignValue&lt;/code&gt; places &lt;code&gt;coords&lt;/code&gt; by value into the foreign bytes of a new foreign object at a given slot. Any changes in the mouse coordinates within the C++ object will not be reflected in the wren object.&lt;/p&gt;

&lt;p&gt;You could also the pass the coordinates by pointer to Wren. An array of foreign bytes is created, but they only hold the pointer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void getMouseCoordinates(WrenVM* vm) {
  // we need to throw away the const-ness of our object -- Wren++ doesn&#39;t
  // respect constness in reference objects
  Vec2i* coords = const_cast&amp;lt;Vec2i*&amp;gt;(&amp;amp;MouseDevice-&amp;gt;get()-&amp;gt;coordinates());
  wrenpp::setSlotForeignPtr&amp;lt;Vec2i&amp;gt;(vm, 0, coords);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now changes in the C++ class&amp;rsquo; coordinates will be reflected in the Wren object, since it points directly to the coordinates in C++.&lt;/p&gt;

&lt;h3 id=&#34;accessing-wren-code-from-c&#34;&gt;Accessing Wren code from C++&lt;/h3&gt;

&lt;p&gt;Accessing Wren code from C++ is, at the time of writing, the most incomplete feature of Wren++, and it will be worked on in the feature. Here&amp;rsquo;s what you can do currently. Wren++ allows you store a references to class methods that you can call from C++. First you need to get the method from the virtual machine instance.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// call the Math.cos(_) method from the previous part of this post
wrenpp::Method cosMethod = vm.method(&amp;quot;main&amp;quot;, &amp;quot;Math&amp;quot;, &amp;quot;cos(_)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The three string arguments to &lt;code&gt;wrenpp::VM::method&lt;/code&gt; are the module name, the variable name that the method is attached to (note again that this would be the class name for a static method!), and finally the method signature itself.&lt;/p&gt;

&lt;p&gt;We call the method by using the parenthesis operator on it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wrenpp::Value val = cosMethod(-5.0);
std::cout &amp;lt;&amp;lt; val.as&amp;lt;double&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Invocations on the parenthesis operator returns an instance of &lt;code&gt;wrenpp::Value&lt;/code&gt;, which is a convenience class that can hold any return value from Wren.&lt;/p&gt;

&lt;h3 id=&#34;in-conclusion&#34;&gt;In conclusion&lt;/h3&gt;

&lt;p&gt;There were some small details I glossed over &amp;ndash; for instance, Wren++ allows you to customize the print, error, and module functions just like in Wren. To see how, take a look at the project&amp;rsquo;s README. Also, Wren access from C++ is likely to develop somewhat as the Wren C API itself develops, but that will be documented in the README once I get around to working on it. Some things that I wish to include in the future is easy access to Wren data structures, such as maps and lists.&lt;/p&gt;

&lt;p&gt;Now it is time for you to go off and explore Wren yourself. You should have the tools to embed Wren in your application with confidence. Wren doesn&amp;rsquo;t have a lot of libraries yet, so you are going to have to reinvent a lot of basic functionality yourself. But that&amp;rsquo;s the best part, naturally! :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Embedding Wren in C&#43;&#43;, part 1</title>
      <link>http://nelari.us/post/wren-embedding-1/</link>
      <pubDate>Thu, 05 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nelari.us/post/wren-embedding-1/</guid>
      <description>

&lt;p&gt;Wren is a small, fast, class-based scripting language designed to be easily embeddable in a host application. As such, it fills very much the same niche as Lua. Why would you choose Wren over Lua in your application? It boils mostly down to stylistic preferences. Wren is very class oriented, and adheres to the curly-brace style tradition, in contrast to Lua&amp;rsquo;s &lt;code&gt;begin...end&lt;/code&gt; blocks. If one of the first things you always did in your Lua projects was design a class model, then Wren might be worth checking out. If you&amp;rsquo;re in the mood for surveying new tech for your C++ application or game engine, then definitely check it out! Wren is currently under active development, so breaking changes might be occasionally introduced. The source code lives on &lt;a href=&#34;https://github.com/munificent/wren&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Even though Wren&amp;rsquo;s embedding API is simple to use, it can be a lot of work to manually write all of the binding code. For that reason, I&amp;rsquo;ve worked on a template-based library to automatically generate the binding code for you. It&amp;rsquo;s called Wren++, and is heavily inspired by libraries like Luabridge for the Lua programming language. You can find it on &lt;a href=&#34;https://github.com/Nelarius/wrenpp&#34;&gt;github&lt;/a&gt; as well.&lt;/p&gt;

&lt;p&gt;This post is divided into two parts. First, I will give an introduction on using Wren&amp;rsquo;s C API via a few examples. You will see how to handle method arguments and return values, as well as how binding C++ classes to Wren works. After you&amp;rsquo;ve seen how Wren&amp;rsquo;s embedding API works, I&amp;rsquo;ll show how those same examples could be done using Wren++.&lt;/p&gt;

&lt;p&gt;A tour of the language itself is a bit beyond the scope of this article, but a very good overview of the language is presented on the Wren website: &lt;a href=&#34;http://wren.io&#34;&gt;wren.io&lt;/a&gt;. If you are not familiar with the language, then I suggest you go there and read before proceeding with this post. You can even test Wren code in the browser over at the &lt;a href=&#34;http://ppvk.github.io/wren-nest/&#34;&gt;wren-nest&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-wren-embedding-api&#34;&gt;The wren embedding API&lt;/h2&gt;

&lt;p&gt;In order to use Wren, you need to link the wren static library to your program. The header file &lt;code&gt;wren.h&lt;/code&gt; also need to be included (located in &lt;code&gt;wren/src/include/&lt;/code&gt;). When you include &lt;code&gt;wren.h&lt;/code&gt; into your C++ source code, don&amp;rsquo;t forget to put it in an &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; block to disable C++ name mangling on the C code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;extern &amp;quot;C&amp;quot; {
#include &amp;lt;wren.h&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The best guide to the embedding API is the &lt;code&gt;wren.h&lt;/code&gt; header file itself, at the moment. I recommend that you have it open and refer to it as needed while reading this post!&lt;/p&gt;

&lt;h3 id=&#34;creating-a-vm&#34;&gt;Creating a VM&lt;/h3&gt;

&lt;p&gt;Having gotten the project set-up out of the way, let&amp;rsquo;s create a new instance of the virtual machine and execute some code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// create the configuration that the virtual machine will use
WrenConfiguration configuration;
// fill the configuration with default values
wrenInitConfiguration(&amp;amp;configuration);

WrenVM* vm = wrenNewVM(&amp;amp;configuration);

// do something with your vm!
WrenInterpretResult result = wrenInterpret(vm, &amp;quot;System.print(\&amp;quot;Hello, world!\&amp;quot;)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything went okay, then result will be &lt;code&gt;WREN_RESULT_SUCCESS&lt;/code&gt;, but &lt;code&gt;WREN_RESULT_COMPILE_ERROR&lt;/code&gt; and &lt;code&gt;WREN_RESULT_RUNTIME_ERROR&lt;/code&gt; can be returned as well. Once you are done with the VM, it can be freed by calling &lt;code&gt;wrenFreeVM(WrenVM* vm)&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;basic-configuration&#34;&gt;Basic configuration&lt;/h3&gt;

&lt;p&gt;The above example doesn&amp;rsquo;t actually print anything, because Wren doesn&amp;rsquo;t know what to do with the &lt;code&gt;System.print&lt;/code&gt; call. You have to provide that function yourself. You can do this by assigning a callback to the configuration&amp;rsquo;s  &lt;code&gt;writeFn&lt;/code&gt; field, which must be a function with the &lt;code&gt;void(WrenVM*, const char*)&lt;/code&gt; signature.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void write(WrenVM* vm, const char* str) {
  std::printf(&amp;quot;%s&amp;quot;, str);
}

// elsewhere...
WrenConfiguration config;
wrenInitConfiguration(&amp;amp;config);
config.writeFn = write;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wren doesn&amp;rsquo;t load modules either by default. Again, you have to provide that function yourself. The module loading function must have the signature &lt;code&gt;char*(WrenVM*, const char*)&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// in this example, module names work the same way as they do in the
// CLI. That is, the module name is specified without the .wren postfix.
char* loadModule(WrenVM* vm, const char* name) {
  std::string path( name );
  path += &amp;quot;.wren&amp;quot;;
  std::ifstream fin;
  fin.open( path, std::ios::in );
  std::stringstream buffer;
  buffer &amp;lt;&amp;lt; fin.rdbuf() &amp;lt;&amp;lt; &#39;\0&#39;;
  std::string source = buffer.str();
  
  char* cbuffer = (char*) malloc( source.size() );
  memcpy( cbuffer, source.c_str(), source.size() );
  return cbuffer;
}

// elsewhere...
config.loadModuleFn = loadModule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that our VM is configured, let&amp;rsquo;s bind some C++ code to it.&lt;/p&gt;

&lt;h3 id=&#34;binding-free-functions-to-wren&#34;&gt;Binding free functions to Wren&lt;/h3&gt;

&lt;p&gt;There are two different hooks for foreign code in Wren. C++ code can be called from foreign methods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class Math {
  foreign static cos(num)
  foreign static sin(num)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++ state may be stored in foreign classes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;foreign class Vec3 {
  foreign plus(rhs)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When Wren encounters a foreign method, it calls a callback function which implements the method. All foreign method callbacks have the same type, &lt;code&gt;typedef void (*WrenForeignMethodFn)(WrenVM*)&lt;/code&gt;, as defined in &lt;code&gt;wren.h&lt;/code&gt;. These callbacks are where your glue code or implementation lives. How does Wren find them? Wren uses another callback function, which should return the correct callback function based on the foreign method&amp;rsquo;s signature. This callback finder (&lt;code&gt;WrenBindForeignMethodFn&lt;/code&gt; in &lt;code&gt;wren.h&lt;/code&gt;) can be assigned to the &lt;code&gt;bindForeignMethodFn&lt;/code&gt; field of &lt;code&gt;WrenConfiguration&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One way of implementing the callback finder is to store the foreign method callback functions as values in a global data structure such as a map, and have the &lt;code&gt;bindForeignMethodFn&lt;/code&gt; find the them using the foreign method signature as a key. Here&amp;rsquo;s the gist of what Wren++ does:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// a map between the foreign method signature and the callback function
std::map&amp;lt;std::string, WrenForeignMethodFn&amp;gt; boundForeignMethods{};

// this function has the signature corresponding to bindForeignMethodFn
WrenForeignMethodFn bindForeignMethod(WrenVM* vm,
                                      const char* module,
                                      const char* className,
                                      bool isStatic,
                                      const char* signature
                                      ) {
  std::string fullSignature{ module };
  fullSignature += className;
  fullSignature += signature;
  if (isStatic) {
      fullSignature += &amp;quot;s&amp;quot;;
  }
  auto it = boundForeignMethods.find(fullSignature);
  if (it != boundsForeignMethods.end()) {
      return it-&amp;gt;second;
  }
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have that in place, let&amp;rsquo;s implement the methods of the &lt;code&gt;Math&lt;/code&gt; class from above. We are going to implement two functions to match the foreign methods in Wren: &lt;code&gt;wrenSin&lt;/code&gt; and &lt;code&gt;wrenCos&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Looking at the declaration for &lt;code&gt;WrenForeignMethodFn&lt;/code&gt;, we can see that we have only the Wren VM instance to work with in our glue code. The Wren VM provides a slot API which we can use to access method arguments, as well as pass return values back to Wren.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;extern &amp;quot;C&amp;quot; {
#include &amp;lt;wren.h&amp;gt;
}
#include &amp;lt;cmath&amp;gt;

void wrenCos(WrenVM* vm) {
  // method arguments are placed in slots 1 and up
  // the receiver of the method (the object) is always in slot 0
  //
  // in Wren, the Number type is actually just a double. So when we pass 
  // a Number as a method argument in Wren, we need to get a double
  // from the slot in C++
  double x = wrenGetSlotDouble(vm, 1);

  // identical methods exist for bool, string, wren values, and foreign objects

  // the method&#39;s return value is taken from slot 0, so let&#39;s place our
  // result there
  wrenSetSlotDouble(vm, 0, std::cos(x));
}

void wrenSin(WrenVM* vm) {
  double x = wrenGetSlotDouble(vm, 1);
  wrenSetSlotDouble(vm, 0, std::sin(x));
}

std::map&amp;lt;std::string, WrenForeignMethodFn&amp;gt; boundForeignMethods{
  { &amp;quot;mainMathcos(_)s&amp;quot;, wrenCos },
  { &amp;quot;mainMathsin(_)s&amp;quot;, wrenSin }
};

WrenForeignMethodFn bindForeignMethod(WrenVM* vm,
                                      const char* module,
                                      const char* className,
                                      bool isStatic,
                                      const char* signature
                                      ) {
  std::string signature{ module };
  signature += className;
  signature += signature;
  if (isStatic) {
      signature += &amp;quot;s&amp;quot;;
  }
  auto it = boundForeignMethods.find(signature);
  if (it != boundsForeignMethods.end()) {
      return it-&amp;gt;second;
  }
  return nullptr;
}

int main() {
  WrenConfiguration configuration;
  wrenInitConfiguration(&amp;amp;configuration);
  configuration.bindForeignMethodFn = bindForeignMethod;
  configuration.writeFn= write;
  configuration.loadModuleFn = loadModule;

  WrenVM* vm = wrenNewVM(&amp;amp;configuration);
  // you can now use the math class
  wrenInterpret(
    vm,
    &amp;quot;class Math {\n&amp;quot;
    &amp;quot;  foreign static cos(num)\n&amp;quot;
    &amp;quot;  foreign static sin(num)\n&amp;quot;
    &amp;quot;}\n&amp;quot;
    &amp;quot;System.print(\&amp;quot;%(Math.cos(1.570796326))\&amp;quot;)\n&amp;quot;
  );
  wrenFreeVM(vm);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that when we initialized &lt;code&gt;boundForeignMethods&lt;/code&gt; with the two bound callbacks, the module&amp;rsquo;s name was &lt;code&gt;main&lt;/code&gt;. If the class whose methods you are implementing are not in a separate file (as was the case above), then the module&amp;rsquo;s name is &lt;code&gt;main&lt;/code&gt;. If the math class had been defined in, say, &lt;code&gt;math.wren&lt;/code&gt;, then the module name would have been &lt;code&gt;math&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can get away with our expensive string concatenation and map-find operations within &lt;code&gt;bindForeignMethod&lt;/code&gt;, because it gets called for each method only once, when the class is defined.&lt;/p&gt;

&lt;p&gt;Also, note that we wrote the signature as &lt;code&gt;cos(_)&lt;/code&gt; and &lt;code&gt;sin(_)&lt;/code&gt;. You don&amp;rsquo;t spell out the argument name in the signature, but instead you replace each argument with an underscore. Since the argument underscores are part of the method signature, you can bind functions to overloaded methods in Wren.&lt;/p&gt;

&lt;h3 id=&#34;binding-classes-to-wren&#34;&gt;Binding classes to Wren&lt;/h3&gt;

&lt;p&gt;Wren can store user-defined state in an instance of a foreign class. We are going to use this feature to bind our C++ types to Wren.&lt;/p&gt;

&lt;p&gt;When Wren encounters a foreign class, it looks up the allocator and finalizer callbacks for that class via a class-finder callback, which behaves very similarly to the &lt;code&gt;bindForeignMethodFn&lt;/code&gt; that we just implemented. Wren uses the allocator callback to create a byte array within the object, and initialize whatever state the user might want to reside within the byte array. The byte array can be accessed via the slot API. The finalizer can be used to call a destructor on the byte array, if necessary. That&amp;rsquo;s all we need to place our C++ objects within Wren objects.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a small foreign class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;foreign class Vec3 {
  // this constructor doesn&#39;t do anything in wren, so we leave it empty
  // however, we want a constructor to fire in C++!
  construct new(x, y, z) {}

  foreign norm()
  foreign dot( rhs )
  foreign cross( rhs )    // returns the result as a new vector

  // accessors
  foreign x
  foreign x=( rhs )
  foreign y
  foreign y=( rhs )
  foreign z
  foreign z=( rhs )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s look at binding the following C++ struct to &lt;code&gt;Vec3&lt;/code&gt; in Wren.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Vec3f {
  union {
    float v[3];
    struct { float x, y, z; };
  };

  Vec3( float x, float y, float z )
  : v{ x, y, z } {}

  Vec3()
  : v{ 0.f, 0.f, 0.f } {}

  float norm() const {
    return sqrt( x*x + y*y + z*z );
  }

  float dot( const Vec3&amp;amp; rhs ) const {
    return x*rhs.x + y*rhs.y + z*rhs.z;
  }

  Vec3 cross( const Vec3&amp;amp; rhs ) const {
    return Vec3 {
      y*rhs.z - z*rhs.y,
      z*rhs.x - x*rhs.z,
      x*rhs.y - y*rhs.x
    };
  }
}; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The binding code is fairly straight forward. We use the slot API like we did before, but this time we also use it to access the foreign byte arrays.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// the allocator has the same signature as any other WrenForeignMethodFn
// the allocator gets called during Vec3.new(_,_,_)
void vec3fAllocate(WrenVM* vm) {
  // this function creates a new instance of the foreign class stored 
  // the slot denoted by the third argument, and places the resulting
  // object in the slot denoted by the second argument
  // remember that the receiver (the Vec3 class) is already in slot zero
  // the fourth argument denotes the size of the byte array to be created
  // finally, the function returns the byte array that it just created
  void* bytes = wrenSetSlotNewForeign(vm, 0, 0, sizeof(Vec3f));
  new (bytes) Vec3f(
    wrenGetSlotDouble(vm, 1),
    wrenGetSlotDouble(vm, 2),
    wrenGetSlotDouble(vm, 3)
  );
}

// the finalizer function has a different signature
// no access to the VM is allowed, because when the finalzer is called,
// the VM is in the middle of a garbage collection
void vec3fFinalize(void* bytes) {
  // do nothing
}

void vec3fNorm(WrenVM* vm) {
  // we can access the byte array of the object in slot zero
  const Vec3f* v = (const Vec3f*)wrenGetSlotForeign(vm, 0);
  wrenSetSlotDouble(vm, 0, v-&amp;gt;norm());
}

void vec3fDot(WrenVM* vm) {
  const Vec3f* lhs = (const Vec3f*)wrenGetSlotForeign(vm, 0);
  const Vec3f* rhs = (const Vec3f*)wrenGetSlotForeign(vm, 1);
  wrenSetSlotDouble(vm, 0, lhs-&amp;gt;dot(*rhs));
}

void vec3fCross(WrenVM* vm) {
  const Vec3f* lhs = (const Vec3f*)wrenGetSlotForeign(vm, 0);
  const Vec3f* rhs = (const Vec3f*)wrenGetSlotForeign(vm, 1);
  Vec3f result = lhs-&amp;gt;cross(*rhs);
  // we need to return a new Vec3f to wren, so we mimic
  // the constructor here
  void* bytes = wrenSetSlotNewForeign(vm, 0, 0, sizeof(Vec3f));
  new (bytes) Vec3f(result);
}

void vec3fGetX(WrenVM* vm) {
  const Vec3f* v = (const Vec3f*)wrenGetSlotForeign(vm, 0);
  wrenSetSlotDouble(vm, 0, v-&amp;gt;x);
}

void vec3fSetX(WrenVM* vm) {
  Vec3f* v = (Vec3f*)wrenGetSlotForeign(vm, 0);
  double newx = wrenGetSlotDouble(vm, 1);
  v-&amp;gt;x = newx;
}

// repeat for y and z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we need to store our methods, allocators and finalizers in their respective data structures, as well as provide Wren a callback for locating the allocators and finalizers based on the module and class name. The class-finder will work much the same way as our method-finder did earlier. Here&amp;rsquo;s what the rest of the program now looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// note that according to the &amp;quot;vector&amp;quot; module name, our Vec3 definition
// now lies in the file vector.wren
std::map&amp;lt;std::string, WrenForeignMethodFn&amp;gt; boundForeignMethods{
  { &amp;quot;vectorVec3norm()&amp;quot;,   vec3fNorm },
  { &amp;quot;vectorVec3dot(_)&amp;quot;,   vec3fDot },
  { &amp;quot;vectorVec3cross(_)&amp;quot;, vec3fCross },
  { &amp;quot;vectorVec3x&amp;quot;,        vec3fGetX },
  { &amp;quot;vectorVec3x=(_)&amp;quot;,    vec3fSetX},
  { &amp;quot;vectorVec3y&amp;quot;,        vec3fGetY },
  { &amp;quot;vectorVec3y=(_)&amp;quot;,    vec3fSetY },
  { &amp;quot;vectorVec3z&amp;quot;,        vec3fGetZ },
  { &amp;quot;vectorVec3z=(_)&amp;quot;,    vec3fSetZ }
};

WrenForeignMethodFn bindForeignMethod(WrenVM*,
                                      const char* module,
                                      const char* className,
                                      bool isStatic,
                                      const char* signature
                                      ) {
  // as before
}

// WrenForeignClassMethods is just a struct containing a
// WrenForeignMethodFn, and a WrenFinalizerFn
std::map&amp;lt;std::string, WrenForeignClassMethods&amp;gt; boundForeignClasses{
  { &amp;quot;vectorVec3&amp;quot;, { vec3fAllocate, vec3fFinalize } }
};

WrenForeignClassFn bindForeignClass(WrenVM*,
                                    const char* module,
                                    const char* className
                                    ) {
  std::string identifier{ module };
  name += className;
  auto it = boundForeignClasses.find(identifier);
  if (it != boundForeignClasses.end()) {
    return it-&amp;gt;second;
  }
  return WrenForeignClassMethods{ nullptr, nullptr };
}

int main() {
  WrenConfiguration configuration;
  wrenInitConfiguration(&amp;amp;configuration);
  configuration.bindForeignMethodFn = bindForeignMethod;
  configuration.bindForeignClassFn = bindForeignClass;
  configuration.writeFn = write;
  configuration.loadModuleFn = loadModule;

  WrenVM* vm = wrenNewVM(&amp;amp;configuration);
  wrenInterpret(
    vm,
    &amp;quot;import \&amp;quot;vector\&amp;quot; for Vec3     \n&amp;quot;
    &amp;quot;var v = Vec3.new(1.0, 2.0, 3.0)\n&amp;quot;
    &amp;quot;var norm = v.norm()            \n&amp;quot;
  );
  wrenFreeVM(vm);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There! With fairly minimal amounts of boiler-plate, you&amp;rsquo;ve wrapped a C++ type for Wren to access. Compared to e.g. Python&amp;rsquo;s embedding API, this is smooth sailing.&lt;/p&gt;

&lt;p&gt;If you have used templates in the past, then you probably were already thinking about ways to generate the above binding functions automatically via template parameters. Especially the allocator and finalizer functions are just begging to be templatized:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void allocateType(WrenVM* vm) {
  void* bytes = wrenSetSlotNewForeign(vm, 0, 0, sizeof(T));
  new (bytes) T();
}

template&amp;lt;typename T&amp;gt;
void finalizeType(void* bytes) {
  T* type = (T*)bytes;
  type-&amp;gt;~T();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise, the foreign method wrappers can be parametrized by the class type as well as the method itself. In this way a unique wrapping function is automatically generated for each method, which we just did by hand. The tricky part is automatically handling arguments and return types. You need to deduce which Wren slot API function to call based on the type of argument &amp;ndash; and then generate code which calls it. It turns out that with C++14&amp;rsquo;s metaprogramming features, that&amp;rsquo;s possible with a surprisingly minimal amount of code. I wrote a separate &lt;a href=&#34;http://nelari.us/post/template-function-args/&#34;&gt;blog post&lt;/a&gt; about that a while back, when I was trying to figure it out for myself. The &amp;ldquo;toy problem&amp;rdquo; that the post is centered around is a template wrapper around Wren&amp;rsquo;s slot API:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// this isn&#39;t exactly the same as in the post because both Wren&#39;s C API
// and my code worked differently back when the post was written
template&amp;lt;typename T&amp;gt;
struct WrenStack;

template&amp;lt;&amp;gt;
struct WrenStack&amp;lt;double&amp;gt; {
    // use this instead of GetArgument&amp;lt;&amp;gt;
    static double get(WrenVM* vm, int slot) {
        return wrenGetSlotDouble( vm, slot);
    }

    // use this instead of Return&amp;lt;&amp;gt;
    static void set(WrenVM* vm, int slot, double val) {
        wrenSetSlotDouble(vm, slot, val);
    }
};

template&amp;lt;&amp;gt;
struct WrenStack&amp;lt;bool&amp;gt; {
    static bool get( WrenVM* vm, int slot ) {
        return wrenGetSlotBool(vm, slot);
    }

    static void set(WrenVM* vm, int slot, bool val) {
        wrenSetSlotBool(vm, slot, val);
    }
};

// etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These structs, along with the compile-time index sequence method from my other blog post, can be used to wrap any function or method with the correct wrenGetSlot/wrenSetSlot function calls.&lt;/p&gt;

&lt;h3 id=&#34;calling-wren-code-from-c&#34;&gt;Calling Wren code from C++&lt;/h3&gt;

&lt;p&gt;Wren allows you to call any method from C++. Arguments are passed and return values received as usual with the slot API. Let&amp;rsquo;s look at how that&amp;rsquo;s done by calling some of the foreign math methods that we bound to wren earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// get the variable based on the module it is in
// and the variable name
// finally, place it in slot zero
wrenGetVariable(vm, &amp;quot;main&amp;quot;, &amp;quot;Math&amp;quot;, 0);
WrenHandle* receiver = wrenGetSlotValue(vm, 0);
WrenHandle* method = wrenMakeCallHandle(vm, &amp;quot;cos(_)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before we can call the method handle, we need to set up the stack via the slot API. The receiver (the object or class whose method we are calling) needs to be placed in slot zero. Any arguments need to be placed in the following slots.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// place the receiver in slot 0
wrenSetSlotHandle(vm, 0, receiver);
wrenSetSlotDouble(vm, 1, M_PI / 2.0);
// now the stack is set -- call the method!
wrenCall(vm, method);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return value is now in slot zero. We know that the return value is a double in this case. But since Wren is dynamically typed, potentially anything could be returned from a method. The C API provides a function to check what type of value is in a slot. Let&amp;rsquo;s make sure that it is indeed a double.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;WrenType returnType = wrenGetSlotType(vm, 0);
assert(returnType == WREN_TYPE_NUM);
double res = wrenGetSlotDouble(vm, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;WrenType&lt;/code&gt; is just an enum with the following values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef enum
{
  WREN_TYPE_BOOL,
  WREN_TYPE_NUM,
  WREN_TYPE_FOREIGN,
  WREN_TYPE_LIST,
  WREN_TYPE_NULL,
  WREN_TYPE_STRING,
  
  // The object is of a type that isn&#39;t accessible by the C API.
  WREN_TYPE_UNKNOWN
} WrenType;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s also completely possible to wrap method calls in template magic. The technique for doing this was not something covered in the previous blog post. The basic problem is the following. We have a function which takes the method call arguments as a template parameter pack. Our receiver and method pointers are set up. We need to call the appropriate &lt;code&gt;wrenSetSlot*&lt;/code&gt; functions in order per function argument.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct WrenMethod {
  WrenHandle* receiver;
  WrenHandle* method;
  WrenVM*    vm;
  
  template&amp;lt;typename... Arg&amp;gt;
  void call(Arg&amp;amp;&amp;amp;... arg) {
    // how do we write a sequence of statements containing
    // WrenStack&amp;lt;Arg&amp;gt;::set(vm, slot, std::forward&amp;lt;Arg&amp;gt;(arg))?
    // We can&#39;t just expand the parameter pack directly within
    // the function&#39;s block scope
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The idea is to use C++11 initializer lists, and expand our calls to &lt;code&gt;WrenStack&amp;lt;T&amp;gt;::set&lt;/code&gt; within the list. We need a dummy type which can be list-initialized.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct ExpandType {
  template&amp;lt;typename... T&amp;gt;
  ExpandType(T&amp;amp;&amp;amp; ...) {}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything you need to know about expanding parameter packs within dummy initializer lists is explained beautifully in this &lt;a href=&#34;http://stackoverflow.com/questions/17339789/how-to-call-a-function-on-all-variadic-template-args&#34;&gt;StackOverflow post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Using the index-list technique from my other blog post, the automatic method calling code will look something like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename... Arg, std::size_t... index&amp;gt;
void passArgumentsToWren(WrenVM* vm, 
                         const std::tuple&amp;lt;Arg...&amp;gt;&amp;amp; tuple,
                         std::index_sequence&amp;lt; index... &amp;gt;) {
    using Traits = ParameterPackTraits&amp;lt;Arg...&amp;gt;;
    ExpandType{
        0,
        (WrenStack&amp;lt;typename Traits::template ParameterType&amp;lt;index&amp;gt;&amp;gt;::set(
            vm,
            index + 1,
            std::get&amp;lt;index&amp;gt;(tuple)
        ), 0)...
    };
}

struct WrenMethod {
  WrenHandle* receiver;
  WrenHandle* method;
  WrenVM*    vm;
  
  template&amp;lt;typename... Arg&amp;gt;
  void call(Arg&amp;amp;&amp;amp;... arg) {
    constexpr std::size_t arity = sizeof...(Arg);
    wrenSetSlotHandle(vm, 0, receiver);
    std::tuple&amp;lt;Arg...&amp;gt; tuple = std::make_tuple(arg...);
    passArgumentsToWren(vm, tuple, std::make_index_sequence&amp;lt;arity&amp;gt;{});
    wrenCall(vm, method);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The beauty of templates is the fact that even though the above looks like it contains lots of overhead code, it is only compile-time overhead. After being compiled, only the correct sequence of &lt;code&gt;wrenSetSlot&lt;/code&gt; statements will remain.&lt;/p&gt;

&lt;h3 id=&#34;next&#34;&gt;Next&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ve now seen some of the functionality that the Wren C API offers. Not everything was covered here; the Wren slot API contains functions for storing values directly in list elements, as well as storing null in a slot. More functions will probably be added in the future &amp;ndash; these will perhaps be visited upon in a future post once the API evolves sufficiently.&lt;/p&gt;

&lt;p&gt;You can read about Wren++ in &lt;a href=&#34;http://nelari.us/post/wren-embedding-2/&#34;&gt;part 2&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Placing an arbitrary number of function calls into a function argument list using templates</title>
      <link>http://nelari.us/post/template-function-args/</link>
      <pubDate>Mon, 31 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://nelari.us/post/template-function-args/</guid>
      <description>

&lt;p&gt;While I was trying to generate code to bind C++ to a scripting language, I discovered that C++ templates, in their current modern form, are not as scary as I used to think they were. Here are a few useful things that I discovered.&lt;/p&gt;

&lt;p&gt;First, in toy form, the problem that I was trying to solve. Suppose I have a free function that I want to bind to a virtual machine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double convertToDegrees( double rad ) {
    return rad * ( 180.0 / 3.14159265359 );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Communication with the virtual machine is carried out with these template functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// When called, returns the argument at position index within the argument list.
template&amp;lt; typename T&amp;gt;
T GetArgument( int index );

// when called, returns the value to the function in the virtual machine.
template&amp;lt; typename T &amp;gt;
void Return( T val );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I could wrap &lt;code&gt;convertToDegrees&lt;/code&gt; in the virtual machine glue code as follows, and give it to the virtual machine&amp;rsquo;s C API.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void wrapper() {
    double res = convertToDegrees( GetArgument&amp;lt;double&amp;gt;( 1 ) );
    Return( res );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But writing this for every function will take time. Additionally, if I were to change the function definition, then I would have to alter the wrapper manually. I want to generate these bindings automatically.&lt;/p&gt;

&lt;p&gt;Given a free function, I want to generate the appropriate calls to GetArgument&lt;T&gt; and place them in the correct order in the function call. Thus, a way to index and get a function&amp;rsquo;s argument types is needed.&lt;/p&gt;

&lt;h2 id=&#34;function-traits&#34;&gt;Function traits&lt;/h2&gt;

&lt;p&gt;Storing function traits can be done easily.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; typename F &amp;gt;
struct function_traits;

template&amp;lt; typename R, typename... Args &amp;gt;
struct function_traits&amp;lt; R( Args... ) &amp;gt; {
    using return_type = R;

    constexpr static const std::size_t arity = sizeof...( Args );

    template&amp;lt; std::size_t N &amp;gt;
    struct argument {
        static_assert( N &amp;lt; arity, &amp;quot;FunctionTraits error: invalid argument count parameter&amp;quot; );
        using type = std::tuple_element_t&amp;lt; N, std::tuple&amp;lt; Args... &amp;gt; &amp;gt;;
    };

    template&amp;lt; std::size_t N &amp;gt;
    using argument_type = typename argument&amp;lt;N&amp;gt;::type;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The class can be used like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;using traits = function_traits&amp;lt; decltype(convertToDegrees) &amp;gt;;
cout &amp;lt;&amp;lt; is_same&amp;lt;double, traits::argument_type&amp;lt;0&amp;gt;&amp;gt;::value &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; is_same&amp;lt;double, traits::return_type&amp;gt;::value &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use the &lt;code&gt;decltype&lt;/code&gt; specifier to get the function&amp;rsquo;s type, or just enter it manually. For &lt;code&gt;convertToDegrees&lt;/code&gt;, the type would be &lt;code&gt;double(double)&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;unpacking-a-tuple-into-a-function-argument-list&#34;&gt;Unpacking a tuple into a function argument list&lt;/h2&gt;

&lt;p&gt;Tuples can be unpacked into a function call surprisingly easily. Use std::index_sequence to generate a non-type parameter pack of indices to index the tuple elements at compile time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; typename Function, typename Tuple, std::size_t... index&amp;gt;
decltype( auto ) invokeHelper( Function&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; tup, std::index_sequence&amp;lt;index...&amp;gt; ) {
    return f( std::get&amp;lt;index&amp;gt;( std::forward&amp;lt;Tuple&amp;gt;(tup) )... );
}

template&amp;lt; typename Function, typename Tuple &amp;gt;
decltype( auto ) invokeWithTuple( Function&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; tup ) {
    constexpr auto Arity = function_traits&amp;lt; std::remove_reference_t&amp;lt;decltype(f)&amp;gt; &amp;gt;::arity;
    return invoke_helper( 
        std::forward&amp;lt;Function&amp;gt;( f ), 
        std::forward&amp;lt;Tuple&amp;gt;( tup ), 
        std::make_index_sequence&amp;lt;Arity&amp;gt;{} 
    );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How exactly does this work? When the ellipsis operator is placed after a pattern containing a variadic parameter, the pattern is instantiated for each instance of the variadic parameter. The instances are separated by commas. In &lt;code&gt;invokeHelper&lt;/code&gt;, the (non-type) variadic parameter is &lt;code&gt;index&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note the C++14-ism in the above code. In C++11, you would write &lt;code&gt;function_traits&amp;lt; typename std::remove_reference&amp;lt;decltype(f)&amp;gt;::type &amp;gt;&lt;/code&gt;. C++14 introduced aliasing, which allows this: &lt;code&gt;template&amp;lt;typename T&amp;gt; using remove_reference_t = typename remove_reference&amp;lt;T&amp;gt;::type;&lt;/code&gt;. All the type traits in &lt;code&gt;type_traits&lt;/code&gt; have aliases of this form in C++14.&lt;/p&gt;

&lt;p&gt;Now this should work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void say( int val, double val2 ) {
    std::cout &amp;lt;&amp;lt; &amp;quot;called with &amp;quot; &amp;lt;&amp;lt; val &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; val2 &amp;lt;&amp;lt; std::endl;
}

int main() {
    auto tup = std::make_tuple( 5, 42.0 );
    invokeWithTuple( say, tup );

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;placing-getargument-t-into-a-function-argument-list&#34;&gt;Placing &lt;code&gt;GetArgument&amp;lt;T&amp;gt;&lt;/code&gt; into a function argument list&lt;/h2&gt;

&lt;p&gt;We can place the calls to &lt;code&gt;GetArgument&amp;lt;T&amp;gt;&lt;/code&gt; in a very similar way.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; typename Function, std::size_t... index&amp;gt;
decltype( auto ) invokeHelper( Function&amp;amp;&amp;amp; f, std::index_sequence&amp;lt;index...&amp;gt; ) {
  using traits = function_traits&amp;lt; std::remove_reference_t&amp;lt;decltype(f)&amp;gt; &amp;gt;;
  return f( GetArgument&amp;lt; typename traits::template argument_type&amp;lt;index&amp;gt; &amp;gt;( index + 1 )... );
}

template&amp;lt; typename Function &amp;gt;
decltype( auto ) invokeWithArguments( Function&amp;amp;&amp;amp; f ) {
  constexpr auto Arity = function_traits&amp;lt; std::remove_reference_t&amp;lt;decltype(f)&amp;gt; &amp;gt;::arity;
  return invoke_helper( 
    std::forward&amp;lt;Function&amp;gt;( f ),
    std::make_index_sequence&amp;lt;Arity&amp;gt;{} 
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;generate-a-unique-wrapper-class-for-a-function&#34;&gt;Generate a unique wrapper class for a function&lt;/h2&gt;

&lt;p&gt;The last piece of my toy puzzle. I call &lt;code&gt;invokeWithArguments&lt;/code&gt; from a static method, so that I can give the static method to the virtual machine&amp;rsquo;s C API.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; typename Signature, Signature&amp;amp; &amp;gt;
struct ForeignMethodWrapper;

template&amp;lt; typename R, typename... Args, R( &amp;amp;P )( Args... ) &amp;gt;
struct ForeignMethodWrapper&amp;lt; R( Args... ), P &amp;gt; {
    static void call() {
        invokeWithArguments( P );
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;invoking-code-conditionally&#34;&gt;Invoking code conditionally&lt;/h2&gt;

&lt;p&gt;Actually, I&amp;rsquo;m not done yet. I still haven&amp;rsquo;t explained how I call &lt;code&gt;Return&amp;lt;T&amp;gt;( T val )&lt;/code&gt; only when the function&amp;rsquo;s return value is not &lt;code&gt;void&lt;/code&gt;. A specialized struct can be used to store the different invocations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// to be used with std::is_void
template&amp;lt;bool predicate&amp;gt;
struct InvokeWithoutReturningIf {
  template&amp;lt; typename Function &amp;gt;
  static void invoke( Function&amp;amp;&amp;amp; f ) {
    invokeWithArguments( std::forward&amp;lt; Function &amp;gt;( f ) );
  }
};

template&amp;lt;&amp;gt;
struct InvokeWithoutReturningIf&amp;lt;false&amp;gt; {
  template&amp;lt; typename Function &amp;gt;
  static void invoke( Function&amp;amp;&amp;amp; f ) {
    using R = function_traits&amp;lt; std::remove_reference_t&amp;lt;decltype(f)&amp;gt; &amp;gt;::return_type;
    Return&amp;lt;R&amp;gt;( invokeWithArguments( std::forward&amp;lt;Function&amp;gt;(f) ) );
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, I modified &lt;code&gt;ForeignMethodWrapper&lt;/code&gt; to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; typename R, typename... Args, R( &amp;amp;P )( Args... ) &amp;gt;
struct ForeignMethodWrapper&amp;lt; R( Args... ), P &amp;gt; {
  static void call() {
    InvokeWithoutReturningIf&amp;lt; std::is_void&amp;lt;R&amp;gt;::value &amp;gt;::invoke( P );
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which completes the solution for my toy problem.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
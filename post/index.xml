<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My thought repository</title>
    <link>http://nelari.us/post/</link>
    <description>Recent content in Posts on My thought repository</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 06 May 2016 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://nelari.us/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Embedding Wren in C&#43;&#43;, part 2</title>
      <link>http://nelari.us/post/wren-embedding-2/</link>
      <pubDate>Fri, 06 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nelari.us/post/wren-embedding-2/</guid>
      <description>

&lt;p&gt;You can read part 1 &lt;a href=&#34;http://nelari.us/post/wren-embedding-1/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Writing you own Wren bindings gives you full control over how your code interfaces with Wren. However, manually implementing the binding code for a large C++-Wren interface can be somewhat time consuming, especially when changes are made to the interface over time. &lt;a href=&#34;https://github.com/nelarius/wrenpp&#34;&gt;Wren++&lt;/a&gt; is a small C++ library that aims to automate most code binding tasks with a minimal runtime overhead. Like Wren itself, Wren++ aims to be simple and minimalistic to use. Here are the features currently supported.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;a RAII wrapper class for the virtual machine instance and refcounted methods&lt;/li&gt;
&lt;li&gt;automatic binding code generation for any C++ type and method&lt;/li&gt;
&lt;li&gt;a convenient way of calling methods from C++ and accessing return values&lt;/li&gt;
&lt;li&gt;template-based &amp;ndash; no macros! If you feel like the binding code in Wren++ is too verbose, you can roll your own macros.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The easiest way to get started with Wren++ is simply to include the source code in your project. Just remember to compile with C++14 features turned on! Alternatively, you can use the included premake script to generate a Makefile or project file for your preferred IDE to generate a static library to link to. In order to use Wren++, include &lt;code&gt;Wren++.h&lt;/code&gt; in your code. You also need to link to the Wren static library.&lt;/p&gt;

&lt;h3 id=&#34;creating-a-vm-instance&#34;&gt;Creating a VM instance&lt;/h3&gt;

&lt;p&gt;Wren++ provides reasonable defaults for the virtual machine configuration. To get started, just write:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;Wren++.h&amp;gt;

int main() {
  wrenpp::VM vm;
  wrenpp::Result result = vm.executeString(&amp;quot;System.print(\&amp;quot;Hello, world\&amp;quot;)&amp;quot;);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like the Wren C API itself, Wren++ provides the interpretation result as an enumeration class. The values are &lt;code&gt;Success&lt;/code&gt;, &lt;code&gt;CompileError&lt;/code&gt;, and &lt;code&gt;RuntimeError&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can also execute code directly from a module:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;auto result = vm.executeModule(&amp;quot;vector&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;module-class-contexts-and-binding-free-functions-to-wren&#34;&gt;Module, class contexts and binding free functions to Wren&lt;/h3&gt;

&lt;p&gt;All method binding takes place in a module and class context. The binding methods return references back to the class context so that you can chain binding commands like in LuaBridge or Luabind. Let&amp;rsquo;s look at binding functions to the &lt;code&gt;Math&lt;/code&gt; class that we did earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wrenpp::beginModule(&amp;quot;main&amp;quot;)
  .beginClass(&amp;quot;Math&amp;quot;)
    .bindFunction&amp;lt;decltype(&amp;amp;cos), &amp;amp;cos&amp;gt;(true, &amp;quot;cos(_)&amp;quot;)
    .bindFunction&amp;lt;decltype(&amp;amp;sin), &amp;amp;sin&amp;gt;(true, &amp;quot;sin(_)&amp;quot;)
  .endClass()
.endModule();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bindFunction&lt;/code&gt; takes two template parameters and two function arguments. The template parameters are the declared type of the function, and then the function pointer value itself. Instead of writing &lt;code&gt;decltype(&amp;amp;cos)&lt;/code&gt;, we could have written &lt;code&gt;double(*)(double)&lt;/code&gt;. As for the function arguments, the boolean indicates whether the method is static, and the string is the method&amp;rsquo;s signature.&lt;/p&gt;

&lt;p&gt;It is entirely optional to include &lt;code&gt;endClass()&lt;/code&gt; and &lt;code&gt;endModule()&lt;/code&gt; at the end of the binding statement. &lt;code&gt;endClass()&lt;/code&gt; returns a reference back to the enclosing module context, so that you can continue binding code to a new class without having to open the context again. Not all binding statements have to be in the same place. You can reopen the module and class contexts somewhere else and continue binding code. All that the module and class contexts do is store the module and class names for binding method to use.&lt;/p&gt;

&lt;h3 id=&#34;binding-types-and-methods-to-wren&#34;&gt;Binding types and methods to Wren&lt;/h3&gt;

&lt;p&gt;Binding types and their methods works very similarly. Let&amp;rsquo;s look at rebinding the &lt;code&gt;Vec3f&lt;/code&gt; example from earlier. When binding a type, we use a different class context. It&amp;rsquo;s created using the template method &lt;code&gt;bindClass&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wrenpp::beginModule(&amp;quot;Vec3&amp;quot;)
  .bindClass&amp;lt;Vec3f, float, float, float&amp;gt;(&amp;quot;Vec3&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;bindClass&lt;/code&gt; tells Wren++ not only to store the name of the class for future reference, but also to generate the allocator and finalizer functions for the given type. The first template parameter is the type of bound class. The following template parameters are optional &amp;ndash; they are the values that can be passed to the bound type&amp;rsquo;s constructor from Wren. The three floats in this example mean that we can construct the type from Wren using three numbers:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;foreign class Vec3 {
  construct new(x, y, z) {}
  // the rest of the methods as before
}

// now we can construct with values
var v = Vec3.new(2.0, 1.0, -3.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even though we can bind to overloaded methods in Wren, we can bind only one constructor to a class.&lt;/p&gt;

&lt;p&gt;Binding the rest of &lt;code&gt;Vec3f&lt;/code&gt;&amp;rsquo;s methods is done using &lt;code&gt;bindMethod&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wrenpp::beginModule(&amp;quot;Vec3&amp;quot;)
  .bindClass&amp;lt;Vec3f, float, float, float&amp;gt;(&amp;quot;Vec3&amp;quot;)
    .bindMethod&amp;lt;decltype(&amp;amp;Ve3f::norm),   &amp;amp;Vec3f::norm&amp;gt;(false, &amp;quot;norm()&amp;quot;)
    .bindMethod&amp;lt;decltype(&amp;amp;Vec3f::dot),   &amp;amp;Vec3f::dot&amp;gt;(false, &amp;quot;dot(_)&amp;quot;)
    .bindMethod&amp;lt;decltype(&amp;amp;Vec3f::cross), &amp;amp;Vec3f::cross&amp;gt;(false, &amp;quot;cross(_)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function arguments have the same meaning as for &lt;code&gt;bindFunction&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, let&amp;rsquo;s bind the accessors for the fields themselves:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  .bindGetter&amp;lt;decltype(Vec3::x), &amp;amp;Vec3::x&amp;gt;(&amp;quot;x&amp;quot;)
  .bindSetter&amp;lt;decltype(Vec3::x), &amp;amp;Vec3::x&amp;gt;(&amp;quot;x=(_)&amp;quot;)
  .bindGetter&amp;lt;decltype(Vec3::y), &amp;amp;Vec3::y&amp;gt;(&amp;quot;y&amp;quot;)
  .bindSetter&amp;lt;decltype(Vec3::y), &amp;amp;Vec3::y&amp;gt;(&amp;quot;y=(_)&amp;quot;)
  .bindGetter&amp;lt;decltype(Vec3::z), &amp;amp;Vec3::z&amp;gt;(&amp;quot;z&amp;quot;)
  .bindSetter&amp;lt;decltype(Vec3::z), &amp;amp;Vec3::z&amp;gt;(&amp;quot;z=(_)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The getters and setters are always non-static.&lt;/p&gt;

&lt;h3 id=&#34;c-and-wren-lifetimes-for-returned-objects&#34;&gt;C++ and Wren lifetimes for returned objects&lt;/h3&gt;

&lt;p&gt;The rules for who owns the returned objects are simple. Objects which are returned from C++ by reference or by pointer have C++ lifetime, and will not be garbage collected by Wren. Objects which are returned from C++ by value have Wren lifetime and are thus garbage collected.&lt;/p&gt;

&lt;h3 id=&#34;binding-your-own-implementations&#34;&gt;Binding your own implementations&lt;/h3&gt;

&lt;p&gt;Sometimes the calling convention of a C++ API is just not very amenable for binding to Wren, and you want to write your own glue code. For instance, pointers to primitive types like &lt;code&gt;float&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt; might be passed to a function. Wren++ simply won&amp;rsquo;t handle function signatures like that, since Wren itself has no concept of out parameters. Instead, Wren++ allows you to bind functions of type &lt;code&gt;WrenForeignMethodFn&lt;/code&gt; directly, so that you may manually implement the foreign function implementation.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at binding the excellent &lt;a href=&#34;https://github.com/ocornut/imgui&#34;&gt;dear imgui&lt;/a&gt; library to Wren. Looking at &lt;code&gt;imgui.h&lt;/code&gt;, you can see lots of long function signatures with pointers to primitive types. We want to provide reasonable default arguments to most of the arguments, as well as return the new values, instead of passing in a reference to the number. Here&amp;rsquo;s the bare-bones Wren-interface we want to implement:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;in a file called imgui.wren

class ImGui {
  foreign static begin( name )
  foreign static end()
  
  // unlike what C++ ImGui does, this RETURNS the new value
  // arguments are all numbers passed by value
  foreign static sliderFloat( label, value, min, max )
  foreign static setWindowSize( size )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s implement wrappers for &lt;code&gt;ImGui::Begin&lt;/code&gt; and &lt;code&gt;ImGui::SliderFloat&lt;/code&gt; with reasonable default values.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void begin(WrenVM* vm) {
  ImGui::Begin((const char*)wrenGetSlotString(vm, 1), NULL, 0);
}

void sliderFloat(WrenVM* vm) {
  const char* label = wrenGetSlotString(vm, 1);
  float value = float(wrenGetSlotDouble(vm, 2));
  float min =   float(wrenGetSlotDouble(vm, 3));
  float max =   float(wrenGetSlotDouble(vm, 4));
  ImGui::SliderFloat(label, &amp;amp;value, min, max);
  wrenSetSlotDouble(vm, 0, value);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;begin&lt;/code&gt; and &lt;code&gt;sliderFloat&lt;/code&gt; functions satisfy the &lt;code&gt;WrenForeignMethodFn&lt;/code&gt; typedef, so we will bind them using the &lt;code&gt;bindCFunction&lt;/code&gt; method. The &lt;code&gt;bindCFunction&lt;/code&gt; method stores the function pointer without generating any calls to the Wren slot API, so that you can do it yourself.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wrenpp::beginModule(&amp;quot;imgui&amp;quot;)
  .beginClass(&amp;quot;ImGui&amp;quot;)
    .bindCFunction(true, &amp;quot;begin(_)&amp;quot;, begin)
    .bindFunction&amp;lt;decltype(&amp;amp;ImGui::End), &amp;amp;ImGui::End&amp;gt;(true, &amp;quot;end()&amp;quot;)
    .bindCFunction(true, &amp;quot;sliderFloat(_,_,_,_)&amp;quot;, sliderFloat)
  .endClass();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we just bound &lt;code&gt;ImGui::End&lt;/code&gt; the usual way since it had a trivial function signature!&lt;/p&gt;

&lt;h4 id=&#34;accessing-foreign-bytes-manually&#34;&gt;Accessing foreign bytes manually&lt;/h4&gt;

&lt;p&gt;Next off, how do we deal with foreign types in our manual foreign method implementations? You can&amp;rsquo;t get the pointer to your foreign type just by using &lt;code&gt;wrenGetSlotForeign&lt;/code&gt;, since Wren++ contains a layer of indirection. The object may live in C++ (C++ lifetime), or within the foreign bytes (Wren lifetime) themselves. Wren++ provides a helper function: &lt;code&gt;wrenpp::getSlotForeign&amp;lt;class T&amp;gt;(WrenVM* vm, int slot)&lt;/code&gt;. To see how it&amp;rsquo;s used, let&amp;rsquo;s wrap &lt;code&gt;ImGui::SetNextWindowSize(const ImVec2&amp;amp;)&lt;/code&gt; for our Wren interface to use. Let&amp;rsquo;s assume that you&amp;rsquo;ve bound &lt;code&gt;ImGui::ImVec2&lt;/code&gt; to Wren &amp;ndash; it&amp;rsquo;s just a simple struct: &lt;code&gt;struct ImVec2 { float x, y; };&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void setWindowSize(WrenVM* vm) {
  ImGui::SetNextWindowSize(*(wrenpp::getSlotForeign&amp;lt;ImVec2&amp;gt;(vm, 1)));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;returning-foreign-types-manually&#34;&gt;Returning foreign types manually&lt;/h4&gt;

&lt;p&gt;You can return values from your manual implementations as well. To see how, let&amp;rsquo;s look at one final slightly contrived example.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class Mouse {
  // returns a Vec2
  foreign static coordinates
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will implement it using our hypothetical &lt;code&gt;MouseDevice&lt;/code&gt; class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// the mouse device
class MouseDevice {
public:
  static MouseDevice* get();
  const Vec2i&amp;amp; coordinates() const;
};

// elsewhere, in the CFunction implementation...
void getMouseCoordinates(WrenVM* vm) {
  Vec2i coords = MouseDevice::get()-&amp;gt;coordinates();
  wrenpp::setSlotForeignValue&amp;lt;Vec2i&amp;gt;(vm, 0, coords);
}

// we will skip over the binding code itself, as you&#39;ve now seen it a few times
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that, as the function&amp;rsquo;s name indices, &lt;code&gt;setSlotForeignValue&lt;/code&gt; places &lt;code&gt;coords&lt;/code&gt; by value into the foreign bytes of a new foreign object at a given slot. Any changes in the mouse coordinates within the C++ object will not be reflected in the wren object.&lt;/p&gt;

&lt;p&gt;You could also the pass the coordinates by pointer to Wren. An array of foreign bytes is created, but they only hold the pointer.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void getMouseCoordinates(WrenVM* vm) {
  // we need to throw away the const-ness of our object -- Wren++ doesn&#39;t
  // respect constness in reference objects
  Vec2i* coords = const_cast&amp;lt;Vec2i*&amp;gt;(&amp;amp;MouseDevice-&amp;gt;get()-&amp;gt;coordinates());
  wrenpp::setSlotForeignPtr&amp;lt;Vec2i&amp;gt;(vm, 0, coords);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now changes in the C++ class&amp;rsquo; coordinates will be reflected in the Wren object, since it points directly to the coordinates in C++.&lt;/p&gt;

&lt;h3 id=&#34;accessing-wren-code-from-c&#34;&gt;Accessing Wren code from C++&lt;/h3&gt;

&lt;p&gt;Accessing Wren code from C++ is, at the time of writing, the most incomplete feature of Wren++, and it will be worked on in the feature. Here&amp;rsquo;s what you can do currently. Wren++ allows you store a references to class methods that you can call from C++. First you need to get the method from the virtual machine instance.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// call the Math.cos(_) method from the previous part of this post
wrenpp::Method cosMethod = vm.method(&amp;quot;main&amp;quot;, &amp;quot;Math&amp;quot;, &amp;quot;cos(_)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The three string arguments to &lt;code&gt;wrenpp::VM::method&lt;/code&gt; are the module name, the variable name that the method is attached to (note again that this would be the class name for a static method!), and finally the method signature itself.&lt;/p&gt;

&lt;p&gt;We call the method by using the parenthesis operator on it.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;wrenpp::Value val = cosMethod(-5.0);
std::cout &amp;lt;&amp;lt; val.as&amp;lt;double&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Invocations on the parenthesis operator returns an instance of &lt;code&gt;wrenpp::Value&lt;/code&gt;, which is a convenience class that can hold any return value from Wren.&lt;/p&gt;

&lt;h3 id=&#34;in-conclusion&#34;&gt;In conclusion&lt;/h3&gt;

&lt;p&gt;There were some small details I glossed over &amp;ndash; for instance, Wren++ allows you to customize the print, error, and module functions just like in Wren. To see how, take a look at the project&amp;rsquo;s README. Also, Wren access from C++ is likely to develop somewhat as the Wren C API itself develops, but that will be documented in the README once I get around to working on it. Some things that I wish to include in the future is easy access to Wren data structures, such as maps and lists.&lt;/p&gt;

&lt;p&gt;Now it is time for you to go off and explore Wren yourself. You should have the tools to embed Wren in your application with confidence. Wren doesn&amp;rsquo;t have a lot of libraries yet, so you are going to have to reinvent a lot of basic functionality yourself. But that&amp;rsquo;s the best part, naturally! :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Embedding Wren in C&#43;&#43;, part 1</title>
      <link>http://nelari.us/post/wren-embedding-1/</link>
      <pubDate>Thu, 05 May 2016 00:00:00 +0000</pubDate>
      
      <guid>http://nelari.us/post/wren-embedding-1/</guid>
      <description>

&lt;p&gt;Wren is a small, fast, class-based scripting language designed to be easily embeddable in a host application. As such, it fills very much the same niche as Lua. Why would you choose Wren over Lua in your application? It boils mostly down to stylistic preferences. Wren is very class oriented, and adheres to the curly-brace style tradition, in contrast to Lua&amp;rsquo;s &lt;code&gt;begin...end&lt;/code&gt; blocks. If one of the first things you always did in your Lua projects was design a class model, then Wren might be worth checking out. If you&amp;rsquo;re in the mood for surveying new tech for your C++ application or game engine, then definitely check it out! Wren is currently under active development, so breaking changes might be occasionally introduced. The source code lives on &lt;a href=&#34;https://github.com/munificent/wren&#34;&gt;github&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Even though Wren&amp;rsquo;s embedding API is simple to use, it can be a lot of work to manually write all of the binding code. For that reason, I&amp;rsquo;ve worked on a template-based library to automatically generate the binding code for you. It&amp;rsquo;s called Wren++, and is heavily inspired by libraries like Luabridge for the Lua programming language. You can find it on &lt;a href=&#34;https://github.com/Nelarius/wrenpp&#34;&gt;github&lt;/a&gt; as well.&lt;/p&gt;

&lt;p&gt;This post is divided into two parts. First, I will give an introduction on using Wren&amp;rsquo;s C API via a few examples. You will see how to handle method arguments and return values, as well as how binding C++ classes to Wren works. After you&amp;rsquo;ve seen how Wren&amp;rsquo;s embedding API works, I&amp;rsquo;ll show how those same examples could be done using Wren++.&lt;/p&gt;

&lt;p&gt;A tour of the language itself is a bit beyond the scope of this article, but a very good overview of the language is presented on the Wren website: &lt;a href=&#34;http://wren.io&#34;&gt;wren.io&lt;/a&gt;. If you are not familiar with the language, then I suggest you go there and read before proceeding with this post. You can even test Wren code in the browser over at the &lt;a href=&#34;http://ppvk.github.io/wren-nest/&#34;&gt;wren-nest&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;the-wren-embedding-api&#34;&gt;The wren embedding API&lt;/h2&gt;

&lt;p&gt;In order to use Wren, you need to link the wren static library to your program. The header file &lt;code&gt;wren.h&lt;/code&gt; also need to be included (located in &lt;code&gt;wren/src/include/&lt;/code&gt;). When you include &lt;code&gt;wren.h&lt;/code&gt; into your C++ source code, don&amp;rsquo;t forget to put it in an &lt;code&gt;extern &amp;quot;C&amp;quot;&lt;/code&gt; block to disable C++ name mangling on the C code:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;extern &amp;quot;C&amp;quot; {
#include &amp;lt;wren.h&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The best guide to the embedding API is the &lt;code&gt;wren.h&lt;/code&gt; header file itself, at the moment. I recommend that you have it open and refer to it as needed while reading this post!&lt;/p&gt;

&lt;h3 id=&#34;creating-a-vm&#34;&gt;Creating a VM&lt;/h3&gt;

&lt;p&gt;Having gotten the project set-up out of the way, let&amp;rsquo;s create a new instance of the virtual machine and execute some code.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// create the configuration that the virtual machine will use
WrenConfiguration configuration;
// fill the configuration with default values
wrenInitConfiguration(&amp;amp;configuration);

WrenVM* vm = wrenNewVM(&amp;amp;configuration);

// do something with your vm!
WrenInterpretResult result = wrenInterpret(vm, &amp;quot;System.print(\&amp;quot;Hello, world!\&amp;quot;)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If everything went okay, then result will be &lt;code&gt;WREN_RESULT_SUCCESS&lt;/code&gt;, but &lt;code&gt;WREN_RESULT_COMPILE_ERROR&lt;/code&gt; and &lt;code&gt;WREN_RESULT_RUNTIME_ERROR&lt;/code&gt; can be returned as well. Once you are done with the VM, it can be freed by calling &lt;code&gt;wrenFreeVM(WrenVM* vm)&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;basic-configuration&#34;&gt;Basic configuration&lt;/h3&gt;

&lt;p&gt;The above example doesn&amp;rsquo;t actually print anything, because Wren doesn&amp;rsquo;t know what to do with the &lt;code&gt;System.print&lt;/code&gt; call. You have to provide that function yourself. You can do this by assigning a callback to the configuration&amp;rsquo;s  &lt;code&gt;writeFn&lt;/code&gt; field, which must be a function with the &lt;code&gt;void(WrenVM*, const char*)&lt;/code&gt; signature.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void write(WrenVM* vm, const char* str) {
  std::printf(&amp;quot;%s&amp;quot;, str);
}

// elsewhere...
WrenConfiguration config;
wrenInitConfiguration(&amp;amp;config);
config.writeFn = write;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wren doesn&amp;rsquo;t load modules either by default. Again, you have to provide that function yourself. The module loading function must have the signature &lt;code&gt;char*(WrenVM*, const char*)&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// in this example, module names work the same way as they do in the
// CLI. That is, the module name is specified without the .wren postfix.
char* loadModule(WrenVM* vm, const char* name) {
  std::string path( name );
  path += &amp;quot;.wren&amp;quot;;
  std::ifstream fin;
  fin.open( path, std::ios::in );
  std::stringstream buffer;
  buffer &amp;lt;&amp;lt; fin.rdbuf() &amp;lt;&amp;lt; &#39;\0&#39;;
  std::string source = buffer.str();
  
  char* cbuffer = (char*) malloc( source.size() );
  memcpy( cbuffer, source.c_str(), source.size() );
  return cbuffer;
}

// elsewhere...
config.loadModuleFn = loadModule;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that our VM is configured, let&amp;rsquo;s bind some C++ code to it.&lt;/p&gt;

&lt;h3 id=&#34;binding-free-functions-to-wren&#34;&gt;Binding free functions to Wren&lt;/h3&gt;

&lt;p&gt;There are two different hooks for foreign code in Wren. C++ code can be called from foreign methods.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;class Math {
  foreign static cos(num)
  foreign static sin(num)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C++ state may be stored in foreign classes.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;foreign class Vec3 {
  foreign plus(rhs)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When Wren encounters a foreign method, it calls a callback function which implements the method. All foreign method callbacks have the same type, &lt;code&gt;typedef void (*WrenForeignMethodFn)(WrenVM*)&lt;/code&gt;, as defined in &lt;code&gt;wren.h&lt;/code&gt;. These callbacks are where your glue code or implementation lives. How does Wren find them? Wren uses another callback function, which should return the correct callback function based on the foreign method&amp;rsquo;s signature. This callback finder (&lt;code&gt;WrenBindForeignMethodFn&lt;/code&gt; in &lt;code&gt;wren.h&lt;/code&gt;) can be assigned to the &lt;code&gt;bindForeignMethodFn&lt;/code&gt; field of &lt;code&gt;WrenConfiguration&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;One way of implementing the callback finder is to store the foreign method callback functions as values in a global data structure such as a map, and have the &lt;code&gt;bindForeignMethodFn&lt;/code&gt; find the them using the foreign method signature as a key. Here&amp;rsquo;s the gist of what Wren++ does:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// a map between the foreign method signature and the callback function
std::map&amp;lt;std::string, WrenForeignMethodFn&amp;gt; boundForeignMethods{};

// this function has the signature corresponding to bindForeignMethodFn
WrenForeignMethodFn bindForeignMethod(WrenVM* vm,
                                      const char* module,
                                      const char* className,
                                      bool isStatic,
                                      const char* signature
                                      ) {
  std::string fullSignature{ module };
  fullSignature += className;
  fullSignature += signature;
  if (isStatic) {
      fullSignature += &amp;quot;s&amp;quot;;
  }
  auto it = boundForeignMethods.find(fullSignature);
  if (it != boundsForeignMethods.end()) {
      return it-&amp;gt;second;
  }
  return nullptr;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have that in place, let&amp;rsquo;s implement the methods of the &lt;code&gt;Math&lt;/code&gt; class from above. We are going to implement two functions to match the foreign methods in Wren: &lt;code&gt;wrenSin&lt;/code&gt; and &lt;code&gt;wrenCos&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Looking at the declaration for &lt;code&gt;WrenForeignMethodFn&lt;/code&gt;, we can see that we have only the Wren VM instance to work with in our glue code. The Wren VM provides a slot API which we can use to access method arguments, as well as pass return values back to Wren.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;extern &amp;quot;C&amp;quot; {
#include &amp;lt;wren.h&amp;gt;
}
#include &amp;lt;cmath&amp;gt;

void wrenCos(WrenVM* vm) {
  // method arguments are placed in slots 1 and up
  // the receiver of the method (the object) is always in slot 0
  //
  // in Wren, the Number type is actually just a double. So when we pass 
  // a Number as a method argument in Wren, we need to get a double
  // from the slot in C++
  double x = wrenGetSlotDouble(vm, 1);

  // identical methods exist for bool, string, wren values, and foreign objects

  // the method&#39;s return value is taken from slot 0, so let&#39;s place our
  // result there
  wrenSetSlotDouble(vm, 0, std::cos(x));
}

void wrenSin(WrenVM* vm) {
  double x = wrenGetSlotDouble(vm, 1);
  wrenSetSlotDouble(vm, 0, std::sin(x));
}

std::map&amp;lt;std::string, WrenForeignMethodFn&amp;gt; boundForeignMethods{
  { &amp;quot;mainMathcos(_)s&amp;quot;, wrenCos },
  { &amp;quot;mainMathsin(_)s&amp;quot;, wrenSin }
};

WrenForeignMethodFn bindForeignMethod(WrenVM* vm,
                                      const char* module,
                                      const char* className,
                                      bool isStatic,
                                      const char* signature
                                      ) {
  std::string signature{ module };
  signature += className;
  signature += signature;
  if (isStatic) {
      signature += &amp;quot;s&amp;quot;;
  }
  auto it = boundForeignMethods.find(signature);
  if (it != boundsForeignMethods.end()) {
      return it-&amp;gt;second;
  }
  return nullptr;
}

int main() {
  WrenConfiguration configuration;
  wrenInitConfiguration(&amp;amp;configuration);
  configuration.bindForeignMethodFn = bindForeignMethod;
  configuration.writeFn= write;
  configuration.loadModuleFn = loadModule;

  WrenVM* vm = wrenNewVM(&amp;amp;configuration);
  // you can now use the math class
  wrenInterpret(
    vm,
    &amp;quot;class Math {\n&amp;quot;
    &amp;quot;  foreign static cos(num)\n&amp;quot;
    &amp;quot;  foreign static sin(num)\n&amp;quot;
    &amp;quot;}\n&amp;quot;
    &amp;quot;System.print(\&amp;quot;%(Math.cos(1.570796326))\&amp;quot;)\n&amp;quot;
  );
  wrenFreeVM(vm);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that when we initialized &lt;code&gt;boundForeignMethods&lt;/code&gt; with the two bound callbacks, the module&amp;rsquo;s name was &lt;code&gt;main&lt;/code&gt;. If the class whose methods you are implementing are not in a separate file (as was the case above), then the module&amp;rsquo;s name is &lt;code&gt;main&lt;/code&gt;. If the math class had been defined in, say, &lt;code&gt;math.wren&lt;/code&gt;, then the module name would have been &lt;code&gt;math&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can get away with our expensive string concatenation and map-find operations within &lt;code&gt;bindForeignMethod&lt;/code&gt;, because it gets called for each method only once, when the class is defined.&lt;/p&gt;

&lt;p&gt;Also, note that we wrote the signature as &lt;code&gt;cos(_)&lt;/code&gt; and &lt;code&gt;sin(_)&lt;/code&gt;. You don&amp;rsquo;t spell out the argument name in the signature, but instead you replace each argument with an underscore. Since the argument underscores are part of the method signature, you can bind functions to overloaded methods in Wren.&lt;/p&gt;

&lt;h3 id=&#34;binding-classes-to-wren&#34;&gt;Binding classes to Wren&lt;/h3&gt;

&lt;p&gt;Wren can store user-defined state in an instance of a foreign class. We are going to use this feature to bind our C++ types to Wren.&lt;/p&gt;

&lt;p&gt;When Wren encounters a foreign class, it looks up the allocator and finalizer callbacks for that class via a class-finder callback, which behaves very similarly to the &lt;code&gt;bindForeignMethodFn&lt;/code&gt; that we just implemented. Wren uses the allocator callback to create a byte array within the object, and initialize whatever state the user might want to reside within the byte array. The byte array can be accessed via the slot API. The finalizer can be used to call a destructor on the byte array, if necessary. That&amp;rsquo;s all we need to place our C++ objects within Wren objects.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a small foreign class.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dart&#34;&gt;foreign class Vec3 {
  // this constructor doesn&#39;t do anything in wren, so we leave it empty
  // however, we want a constructor to fire in C++!
  construct new(x, y, z) {}

  foreign norm()
  foreign dot( rhs )
  foreign cross( rhs )    // returns the result as a new vector

  // accessors
  foreign x
  foreign x=( rhs )
  foreign y
  foreign y=( rhs )
  foreign z
  foreign z=( rhs )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s look at binding the following C++ struct to &lt;code&gt;Vec3&lt;/code&gt; in Wren.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct Vec3f {
  union {
    float v[3];
    struct { float x, y, z; };
  };

  Vec3( float x, float y, float z )
  : v{ x, y, z } {}

  Vec3()
  : v{ 0.f, 0.f, 0.f } {}

  float norm() const {
    return sqrt( x*x + y*y + z*z );
  }

  float dot( const Vec3&amp;amp; rhs ) const {
    return x*rhs.x + y*rhs.y + z*rhs.z;
  }

  Vec3 cross( const Vec3&amp;amp; rhs ) const {
    return Vec3 {
      y*rhs.z - z*rhs.y,
      z*rhs.x - x*rhs.z,
      x*rhs.y - y*rhs.x
    };
  }
}; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The binding code is fairly straight forward. We use the slot API like we did before, but this time we also use it to access the foreign byte arrays.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// the allocator has the same signature as any other WrenForeignMethodFn
// the allocator gets called during Vec3.new(_,_,_)
void vec3fAllocate(WrenVM* vm) {
  // this function creates a new instance of the foreign class stored 
  // the slot denoted by the third argument, and places the resulting
  // object in the slot denoted by the second argument
  // remember that the receiver (the Vec3 class) is already in slot zero
  // the fourth argument denotes the size of the byte array to be created
  // finally, the function returns the byte array that it just created
  void* bytes = wrenSetSlotNewForeign(vm, 0, 0, sizeof(Vec3f));
  new (bytes) Vec3f(
    wrenGetSlotDouble(vm, 1),
    wrenGetSlotDouble(vm, 2),
    wrenGetSlotDouble(vm, 3)
  );
}

// the finalizer function has a different signature
// no access to the VM is allowed, because when the finalzer is called,
// the VM is in the middle of a garbage collection
void vec3fFinalize(void* bytes) {
  // do nothing
}

void vec3fNorm(WrenVM* vm) {
  // we can access the byte array of the object in slot zero
  const Vec3f* v = (const Vec3f*)wrenGetSlotForeign(vm, 0);
  wrenSetSlotDouble(vm, 0, v-&amp;gt;norm());
}

void vec3fDot(WrenVM* vm) {
  const Vec3f* lhs = (const Vec3f*)wrenGetSlotForeign(vm, 0);
  const Vec3f* rhs = (const Vec3f*)wrenGetSlotForeign(vm, 1);
  wrenSetSlotDouble(vm, 0, lhs-&amp;gt;dot(*rhs));
}

void vec3fCross(WrenVM* vm) {
  const Vec3f* lhs = (const Vec3f*)wrenGetSlotForeign(vm, 0);
  const Vec3f* rhs = (const Vec3f*)wrenGetSlotForeign(vm, 1);
  Vec3f result = lhs-&amp;gt;cross(*rhs);
  // we need to return a new Vec3f to wren, so we mimic
  // the constructor here
  void* bytes = wrenSetSlotNewForeign(vm, 0, 0, sizeof(Vec3f));
  new (bytes) Vec3f(result);
}

void vec3fGetX(WrenVM* vm) {
  const Vec3f* v = (const Vec3f*)wrenGetSlotForeign(vm, 0);
  wrenSetSlotDouble(vm, 0, v-&amp;gt;x);
}

void vec3fSetX(WrenVM* vm) {
  Vec3f* v = (Vec3f*)wrenGetSlotForeign(vm, 0);
  double newx = wrenGetSlotDouble(vm, 1);
  v-&amp;gt;x = newx;
}

// repeat for y and z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we need to store our methods, allocators and finalizers in their respective data structures, as well as provide Wren a callback for locating the allocators and finalizers based on the module and class name. The class-finder will work much the same way as our method-finder did earlier. Here&amp;rsquo;s what the rest of the program now looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// note that according to the &amp;quot;vector&amp;quot; module name, our Vec3 definition
// now lies in the file vector.wren
std::map&amp;lt;std::string, WrenForeignMethodFn&amp;gt; boundForeignMethods{
  { &amp;quot;vectorVec3norm()&amp;quot;,   vec3fNorm },
  { &amp;quot;vectorVec3dot(_)&amp;quot;,   vec3fDot },
  { &amp;quot;vectorVec3cross(_)&amp;quot;, vec3fCross },
  { &amp;quot;vectorVec3x&amp;quot;,        vec3fGetX },
  { &amp;quot;vectorVec3x=(_)&amp;quot;,    vec3fSetX},
  { &amp;quot;vectorVec3y&amp;quot;,        vec3fGetY },
  { &amp;quot;vectorVec3y=(_)&amp;quot;,    vec3fSetY },
  { &amp;quot;vectorVec3z&amp;quot;,        vec3fGetZ },
  { &amp;quot;vectorVec3z=(_)&amp;quot;,    vec3fSetZ }
};

WrenForeignMethodFn bindForeignMethod(WrenVM*,
                                      const char* module,
                                      const char* className,
                                      bool isStatic,
                                      const char* signature
                                      ) {
  // as before
}

// WrenForeignClassMethods is just a struct containing a
// WrenForeignMethodFn, and a WrenFinalizerFn
std::map&amp;lt;std::string, WrenForeignClassMethods&amp;gt; boundForeignClasses{
  { &amp;quot;vectorVec3&amp;quot;, { vec3fAllocate, vec3fFinalize } }
};

WrenForeignClassFn bindForeignClass(WrenVM*,
                                    const char* module,
                                    const char* className
                                    ) {
  std::string identifier{ module };
  name += className;
  auto it = boundForeignClasses.find(identifier);
  if (it != boundForeignClasses.end()) {
    return it-&amp;gt;second;
  }
  return WrenForeignClassMethods{ nullptr, nullptr };
}

int main() {
  WrenConfiguration configuration;
  wrenInitConfiguration(&amp;amp;configuration);
  configuration.bindForeignMethodFn = bindForeignMethod;
  configuration.bindForeignClassFn = bindForeignClass;
  configuration.writeFn = write;
  configuration.loadModuleFn = loadModule;

  WrenVM* vm = wrenNewVM(&amp;amp;configuration);
  wrenInterpret(
    vm,
    &amp;quot;import \&amp;quot;vector\&amp;quot; for Vec3     \n&amp;quot;
    &amp;quot;var v = Vec3.new(1.0, 2.0, 3.0)\n&amp;quot;
    &amp;quot;var norm = v.norm()            \n&amp;quot;
  );
  wrenFreeVM(vm);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There! With fairly minimal amounts of boiler-plate, you&amp;rsquo;ve wrapped a C++ type for Wren to access. Compared to e.g. Python&amp;rsquo;s embedding API, this is smooth sailing.&lt;/p&gt;

&lt;p&gt;If you have used templates in the past, then you probably were already thinking about ways to generate the above binding functions automatically via template parameters. Especially the allocator and finalizer functions are just begging to be templatized:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
void allocateType(WrenVM* vm) {
  void* bytes = wrenSetSlotNewForeign(vm, 0, 0, sizeof(T));
  new (bytes) T();
}

template&amp;lt;typename T&amp;gt;
void finalizeType(void* bytes) {
  T* type = (T*)bytes;
  type-&amp;gt;~T();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise, the foreign method wrappers can be parametrized by the class type as well as the method itself. In this way a unique wrapping function is automatically generated for each method, which we just did by hand. The tricky part is automatically handling arguments and return types. You need to deduce which Wren slot API function to call based on the type of argument &amp;ndash; and then generate code which calls it. It turns out that with C++14&amp;rsquo;s metaprogramming features, that&amp;rsquo;s possible with a surprisingly minimal amount of code. I wrote a separate &lt;a href=&#34;http://www.johannmuszynski.com/blog/post/modern_c_templates_are_your_friend/&#34;&gt;blog post&lt;/a&gt; about that a while back, when I was trying to figure it out for myself. The &amp;ldquo;toy problem&amp;rdquo; that the post is centered around is a template wrapper around Wren&amp;rsquo;s slot API:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// this isn&#39;t exactly the same as in the post because both Wren&#39;s C API
// and my code worked differently back when the post was written
template&amp;lt;typename T&amp;gt;
struct WrenStack;

template&amp;lt;&amp;gt;
struct WrenStack&amp;lt;double&amp;gt; {
    // use this instead of GetArgument&amp;lt;&amp;gt;
    static double get(WrenVM* vm, int slot) {
        return wrenGetSlotDouble( vm, slot);
    }

    // use this instead of Return&amp;lt;&amp;gt;
    static void set(WrenVM* vm, int slot, double val) {
        wrenSetSlotDouble(vm, slot, val);
    }
};

template&amp;lt;&amp;gt;
struct WrenStack&amp;lt;bool&amp;gt; {
    static bool get( WrenVM* vm, int slot ) {
        return wrenGetSlotBool(vm, slot);
    }

    static void set(WrenVM* vm, int slot, bool val) {
        wrenSetSlotBool(vm, slot, val);
    }
};

// etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These structs, along with the compile-time index sequence method from my other blog post, can be used to wrap any function or method with the correct wrenGetSlot/wrenSetSlot function calls.&lt;/p&gt;

&lt;h3 id=&#34;calling-wren-code-from-c&#34;&gt;Calling Wren code from C++&lt;/h3&gt;

&lt;p&gt;Wren allows you to call any method from C++. Arguments are passed and return values received as usual with the slot API. Let&amp;rsquo;s look at how that&amp;rsquo;s done by calling some of the foreign math methods that we bound to wren earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// get the variable based on the module it is in
// and the variable name
// finally, place it in slot zero
wrenGetVariable(vm, &amp;quot;main&amp;quot;, &amp;quot;Math&amp;quot;, 0);
WrenValue* receiver = wrenGetSlotValue(vm, 0);
WrenValue* method = wrenMakeCallHandle(vm, &amp;quot;cos(_)&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before we can call the method handle, we need to set up the stack via the slot API. The receiver (the object or class whose method we are calling) needs to be placed in slot zero. Any arguments need to be placed in the following slots.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// place the receiver in slot 0
wrenSetSlotValue(vm, 0, receiver);
wrenSetSlotDouble(vm, 1, M_PI / 2.0);
// now the stack is set -- call the method!
wrenCall(vm, method);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The return value is now in slot zero. We know that the return value is a double in this case. But since Wren is dynamically typed, potentially anything could be returned from a method. The C API provides a function to check what type of value is in a slot. Let&amp;rsquo;s make sure that it is indeed a double.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;WrenType returnType = wrenGetSlotType(vm, 0);
assert(returnType == WREN_TYPE_NUM);
double res = wrenGetSlotDouble(vm, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;WrenType&lt;/code&gt; is just an enum with the following values:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef enum
{
  WREN_TYPE_BOOL,
  WREN_TYPE_NUM,
  WREN_TYPE_FOREIGN,
  WREN_TYPE_LIST,
  WREN_TYPE_NULL,
  WREN_TYPE_STRING,
  
  // The object is of a type that isn&#39;t accessible by the C API.
  WREN_TYPE_UNKNOWN
} WrenType;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s also completely possible to wrap method calls in template magic. The technique for doing this was not something covered in the previous blog post. The basic problem is the following. We have a function which takes the method call arguments as a template parameter pack. Our receiver and method pointers are set up. We need to call the appropriate &lt;code&gt;wrenSetSlot*&lt;/code&gt; functions in order per function argument.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct WrenMethod {
  WrenValue* receiver;
  WrenValue* method;
  WrenVM*    vm;
  
  template&amp;lt;typename... Arg&amp;gt;
  void call(Arg&amp;amp;&amp;amp;... arg) {
    // how do we write a sequence of statements containing
    // WrenStack&amp;lt;Arg&amp;gt;::set(vm, slot, std::forward&amp;lt;Arg&amp;gt;(arg))?
    // We can&#39;t just expand the parameter pack directly within
    // the function&#39;s block scope
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The idea is to use C++11 initializer lists, and expand our calls to &lt;code&gt;WrenStack&amp;lt;T&amp;gt;::set&lt;/code&gt; within the list. We need a dummy type which can be list-initialized.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;struct ExpandType {
  template&amp;lt;typename... T&amp;gt;
  ExpandType(T&amp;amp;&amp;amp; ...) {}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything you need to know about expanding parameter packs within dummy initializer lists is explained beautifully in this &lt;a href=&#34;http://stackoverflow.com/questions/17339789/how-to-call-a-function-on-all-variadic-template-args&#34;&gt;StackOverflow post&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Using the index-list technique from my other blog post, the automatic method calling code will look something like this.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename... Arg, std::size_t... index&amp;gt;
void passArgumentsToWren(WrenVM* vm, 
                         const std::tuple&amp;lt;Arg...&amp;gt;&amp;amp; tuple,
                         std::index_sequence&amp;lt; index... &amp;gt;) {
    using Traits = ParameterPackTraits&amp;lt;Arg...&amp;gt;;
    ExpandType{
        0,
        (WrenStack&amp;lt;typename Traits::template ParameterType&amp;lt;index&amp;gt;&amp;gt;::set(
            vm,
            index + 1,
            std::get&amp;lt;index&amp;gt;(tuple)
        ), 0)...
    };
}

struct WrenMethod {
  WrenValue* receiver;
  WrenValue* method;
  WrenVM*    vm;
  
  template&amp;lt;typename... Arg&amp;gt;
  void call(Arg&amp;amp;&amp;amp;... arg) {
    constexpr std::size_t arity = sizeof...(Arg);
    wrenSetSlotValue(vm, 0, receiver);
    std::tuple&amp;lt;Arg...&amp;gt; tuple = std::make_tuple(arg...);
    passArgumentsToWren(vm, tuple, std::make_index_sequence&amp;lt;arity&amp;gt;{});
    wrenCall(vm, method);
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The beauty of templates is the fact that even though the above looks like it contains lots of overhead code, it is only compile-time overhead. After being compiled, only the correct sequence of &lt;code&gt;wrenSetSlot&lt;/code&gt; statements will remain.&lt;/p&gt;

&lt;h3 id=&#34;next&#34;&gt;Next&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ve now seen some of the functionality that the Wren C API offers. Not everything was covered here; the Wren slot API contains functions for storing values directly in list elements, as well as storing null in a slot. More functions will probably be added in the future &amp;ndash; these will perhaps be visited upon in a future post once the API evolves sufficiently.&lt;/p&gt;

&lt;p&gt;You can read about Wren++ in &lt;a href=&#34;nelari.us/post/wren-embedding-2/&#34;&gt;part 2&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Placing an arbitrary number of function calls into a function argument list using templates</title>
      <link>http://nelari.us/post/template-function-args/</link>
      <pubDate>Mon, 31 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>http://nelari.us/post/template-function-args/</guid>
      <description>

&lt;p&gt;While I was trying to generate code to bind C++ to a scripting language, I discovered that C++ templates, in their current modern form, are not as scary as I used to think they were. Here are a few useful things that I discovered.&lt;/p&gt;

&lt;p&gt;First, in toy form, the problem that I was trying to solve. Suppose I have a free function that I want to bind to a virtual machine.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;double convertToDegrees( double rad ) {
    return rad * ( 180.0 / 3.14159265359 );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Communication with the virtual machine is carried out with these template functions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// When called, returns the argument at position index within the argument list.
template&amp;lt; typename T&amp;gt;
T GetArgument( int index );

// when called, returns the value to the function in the virtual machine.
template&amp;lt; typename T &amp;gt;
void Return( T val );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I could wrap &lt;code&gt;convertToDegrees&lt;/code&gt; in the virtual machine glue code as follows, and give it to the virtual machine&amp;rsquo;s C API.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void wrapper() {
    double res = convertToDegrees( GetArgument&amp;lt;double&amp;gt;( 1 ) );
    Return( res );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But writing this for every function will take time. Additionally, if I were to change the function definition, then I would have to alter the wrapper manually. I want to generate these bindings automatically.&lt;/p&gt;

&lt;p&gt;Given a free function, I want to generate the appropriate calls to GetArgument&lt;T&gt; and place them in the correct order in the function call. Thus, a way to index and get a function&amp;rsquo;s argument types is needed.&lt;/p&gt;

&lt;h2 id=&#34;function-traits&#34;&gt;Function traits&lt;/h2&gt;

&lt;p&gt;Storing function traits can be done easily.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; typename F &amp;gt;
struct function_traits;

template&amp;lt; typename R, typename... Args &amp;gt;
struct function_traits&amp;lt; R( Args... ) &amp;gt; {
    using return_type = R;

    constexpr static const std::size_t arity = sizeof...( Args );

    template&amp;lt; std::size_t N &amp;gt;
    struct argument {
        static_assert( N &amp;lt; arity, &amp;quot;FunctionTraits error: invalid argument count parameter&amp;quot; );
        using type = std::tuple_element_t&amp;lt; N, std::tuple&amp;lt; Args... &amp;gt; &amp;gt;;
    };

    template&amp;lt; std::size_t N &amp;gt;
    using argument_type = typename argument&amp;lt;N&amp;gt;::type;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The class can be used like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;using traits = function_traits&amp;lt; decltype(convertToDegrees) &amp;gt;;
cout &amp;lt;&amp;lt; is_same&amp;lt;double, traits::argument_type&amp;lt;0&amp;gt;&amp;gt;::value &amp;lt;&amp;lt; endl;
cout &amp;lt;&amp;lt; is_same&amp;lt;double, traits::return_type&amp;gt;::value &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use the &lt;code&gt;decltype&lt;/code&gt; specifier to get the function&amp;rsquo;s type, or just enter it manually. For &lt;code&gt;convertToDegrees&lt;/code&gt;, the type would be &lt;code&gt;double(double)&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;unpacking-a-tuple-into-a-function-argument-list&#34;&gt;Unpacking a tuple into a function argument list&lt;/h2&gt;

&lt;p&gt;Tuples can be unpacked into a function call surprisingly easily. Use std::index_sequence to generate a non-type parameter pack of indices to index the tuple elements at compile time.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; typename Function, typename Tuple, std::size_t... index&amp;gt;
decltype( auto ) invokeHelper( Function&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; tup, std::index_sequence&amp;lt;index...&amp;gt; ) {
    return f( std::get&amp;lt;index&amp;gt;( std::forward&amp;lt;Tuple&amp;gt;(tup) )... );
}

template&amp;lt; typename Function, typename Tuple &amp;gt;
decltype( auto ) invokeWithTuple( Function&amp;amp;&amp;amp; f, Tuple&amp;amp;&amp;amp; tup ) {
    constexpr auto Arity = function_traits&amp;lt; std::remove_reference_t&amp;lt;decltype(f)&amp;gt; &amp;gt;::arity;
    return invoke_helper( 
        std::forward&amp;lt;Function&amp;gt;( f ), 
        std::forward&amp;lt;Tuple&amp;gt;( tup ), 
        std::make_index_sequence&amp;lt;Arity&amp;gt;{} 
    );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How exactly does this work? When the ellipsis operator is placed after a pattern containing a variadic parameter, the pattern is instantiated for each instance of the variadic parameter. The instances are separated by commas. In &lt;code&gt;invokeHelper&lt;/code&gt;, the (non-type) variadic parameter is &lt;code&gt;index&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note the C++14-ism in the above code. In C++11, you would write &lt;code&gt;function_traits&amp;lt; typename std::remove_reference&amp;lt;decltype(f)&amp;gt;::type &amp;gt;&lt;/code&gt;. C++14 introduced aliasing, which allows this: &lt;code&gt;template&amp;lt;typename T&amp;gt; using remove_reference_t = typename remove_reference&amp;lt;T&amp;gt;::type;&lt;/code&gt;. All the type traits in &lt;code&gt;type_traits&lt;/code&gt; have aliases of this form in C++14.&lt;/p&gt;

&lt;p&gt;Now this should work:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;void say( int val, double val2 ) {
    std::cout &amp;lt;&amp;lt; &amp;quot;called with &amp;quot; &amp;lt;&amp;lt; val &amp;lt;&amp;lt; &amp;quot;, &amp;quot; &amp;lt;&amp;lt; val2 &amp;lt;&amp;lt; std::endl;
}

int main() {
    auto tup = std::make_tuple( 5, 42.0 );
    invokeWithTuple( say, tup );

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;placing-getargument-t-into-a-function-argument-list&#34;&gt;Placing &lt;code&gt;GetArgument&amp;lt;T&amp;gt;&lt;/code&gt; into a function argument list&lt;/h2&gt;

&lt;p&gt;We can place the calls to &lt;code&gt;GetArgument&amp;lt;T&amp;gt;&lt;/code&gt; in a very similar way.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; typename Function, std::size_t... index&amp;gt;
decltype( auto ) invokeHelper( Function&amp;amp;&amp;amp; f, std::index_sequence&amp;lt;index...&amp;gt; ) {
  using traits = function_traits&amp;lt; std::remove_reference_t&amp;lt;decltype(f)&amp;gt; &amp;gt;;
  return f( GetArgument&amp;lt; typename traits::template argument_type&amp;lt;index&amp;gt; &amp;gt;( index + 1 )... );
}

template&amp;lt; typename Function &amp;gt;
decltype( auto ) invokeWithArguments( Function&amp;amp;&amp;amp; f ) {
  constexpr auto Arity = function_traits&amp;lt; std::remove_reference_t&amp;lt;decltype(f)&amp;gt; &amp;gt;::arity;
  return invoke_helper( 
    std::forward&amp;lt;Function&amp;gt;( f ),
    std::make_index_sequence&amp;lt;Arity&amp;gt;{} 
  );
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;generate-a-unique-wrapper-class-for-a-function&#34;&gt;Generate a unique wrapper class for a function&lt;/h2&gt;

&lt;p&gt;The last piece of my toy puzzle. I call &lt;code&gt;invokeWithArguments&lt;/code&gt; from a static method, so that I can give the static method to the virtual machine&amp;rsquo;s C API.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; typename Signature, Signature&amp;amp; &amp;gt;
struct ForeignMethodWrapper;

template&amp;lt; typename R, typename... Args, R( &amp;amp;P )( Args... ) &amp;gt;
struct ForeignMethodWrapper&amp;lt; R( Args... ), P &amp;gt; {
    static void call() {
        invokeWithArguments( P );
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;invoking-code-conditionally&#34;&gt;Invoking code conditionally&lt;/h2&gt;

&lt;p&gt;Actually, I&amp;rsquo;m not done yet. I still haven&amp;rsquo;t explained how I call &lt;code&gt;Return&amp;lt;T&amp;gt;( T val )&lt;/code&gt; only when the function&amp;rsquo;s return value is not &lt;code&gt;void&lt;/code&gt;. A specialized struct can be used to store the different invocations.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// to be used with std::is_void
template&amp;lt;bool predicate&amp;gt;
struct InvokeWithoutReturningIf {
  template&amp;lt; typename Function &amp;gt;
  static void invoke( Function&amp;amp;&amp;amp; f ) {
    invokeWithArguments( std::forward&amp;lt; Function &amp;gt;( f ) );
  }
};

template&amp;lt;&amp;gt;
struct InvokeWithoutReturningIf&amp;lt;false&amp;gt; {
  template&amp;lt; typename Function &amp;gt;
  static void invoke( Function&amp;amp;&amp;amp; f ) {
    using R = function_traits&amp;lt; std::remove_reference_t&amp;lt;decltype(f)&amp;gt; &amp;gt;::return_type;
    Return&amp;lt;R&amp;gt;( invokeWithArguments( std::forward&amp;lt;Function&amp;gt;(f) ) );
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, I modified &lt;code&gt;ForeignMethodWrapper&lt;/code&gt; to&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt; typename R, typename... Args, R( &amp;amp;P )( Args... ) &amp;gt;
struct ForeignMethodWrapper&amp;lt; R( Args... ), P &amp;gt; {
  static void call() {
    InvokeWithoutReturningIf&amp;lt; std::is_void&amp;lt;R&amp;gt;::value &amp;gt;::invoke( P );
  }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which completes the solution for my toy problem.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>raytracing on My thought repository</title>
    <link>https://nelari.us/tags/raytracing/</link>
    <description>Recent content in raytracing on My thought repository</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 12 Jun 2025 08:30:16 +0300</lastBuildDate><atom:link href="https://nelari.us/tags/raytracing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Experiments with wavefront ray tracing on Apple silicon</title>
      <link>https://nelari.us/post/wavefront-ray-tracing/</link>
      <pubDate>Thu, 12 Jun 2025 08:30:16 +0300</pubDate>
      
      <guid>https://nelari.us/post/wavefront-ray-tracing/</guid>
      <description>Books, articles, and blog posts present the wavefront renderer architecture as a way to improve ray tracing performance on GPUs. In practice, it&amp;rsquo;s difficult to find information on whether I should expect performance improvements for my monolithic kernel hobby renderer on Apple&amp;rsquo;s M1, M2, or M3 chips—the latter having hardware-accelerated ray tracing. On Apple hardware, would switching to a wavefront architecture be a silver bullet yielding better performance?
There&amp;rsquo;s only one way to find out: write both a monolithic and a wavefront ray tracer with identical features and measure their performance across different devices.</description>
    </item>
    
    <item>
      <title>Pathtracing tidbits: integrating animated blue noise</title>
      <link>https://nelari.us/post/animated-blue-noise/</link>
      <pubDate>Sun, 12 Jan 2025 14:46:00 +0200</pubDate>
      
      <guid>https://nelari.us/post/animated-blue-noise/</guid>
      <description>Alan Wolfe&amp;rsquo;s paper, &amp;ldquo;Using Blue Noise for Ray Traced Soft Shadows&amp;rdquo;, presents a great method for reducing the perceived noise in soft shadows. It can be readily adapted to a path tracer as well, where it will yield images with better clarity, even with only a few samples.
Take a look at an image rendered with regular RNG white noise in the left half, and blue noise in the right half:</description>
    </item>
    
    <item>
      <title>A quick look at Apple Silicon&#39;s hardware accelerated ray tracing performance</title>
      <link>https://nelari.us/post/metal-raytracing-performance/</link>
      <pubDate>Sun, 01 Sep 2024 07:22:51 +0300</pubDate>
      
      <guid>https://nelari.us/post/metal-raytracing-performance/</guid>
      <description>To develop my main ray tracing renderer project, I have been working on a Macbook Air with an M2 chip. The renderer&amp;rsquo;s performance on the laptop has not been great, with frame rates in the decimals at fullscreen resolutions.
The M3 chip was introduced fairly recently (half a year ago at the time of writing) with support for ray tracing in the hardware. Anectodally, I have seen reports of 100 % improvements in performance.</description>
    </item>
    
    <item>
      <title>GPU Pathtracer Devlog</title>
      <link>https://nelari.us/post/pathtracer_devlog/</link>
      <pubDate>Mon, 30 Oct 2023 17:19:21 +0200</pubDate>
      
      <guid>https://nelari.us/post/pathtracer_devlog/</guid>
      <description>This post is a devlog for my rayfinder project. Follow along to see the progress, starting from scratch by opening a simple window.
First step towards temporal filtering: simple accumulation 2024-06-24
Commit: 29eebc8
The first step towards temporal accumulation with a moving camera is implemented. The reference path tracer previously implemented temporal accumulation, but only when the camera was stationary. When the camera was moved, the render was invalidated and started from scratch.</description>
    </item>
    
    <item>
      <title>Weekend raytracing with wgpu, part 2</title>
      <link>https://nelari.us/post/weekend_raytracing_with_wgpu_2/</link>
      <pubDate>Sat, 27 May 2023 21:47:16 +0300</pubDate>
      
      <guid>https://nelari.us/post/weekend_raytracing_with_wgpu_2/</guid>
      <description>The first part of &amp;ldquo;Weekend raytracing with wgpu&amp;rdquo; left us with a basic implementation of Peter Shirley&amp;rsquo;s first book in the series of &amp;ldquo;Ray Tracing In One Weekend &amp;quot; books. &amp;ldquo;Ray Tracing: The Next Week&amp;rdquo; introduces additional features, such as texture support.
This post takes a look at adding a physically based sky model, in addition to adding textured material support. These features, combined, result in much nicer images than the basic renderer, without appreciably slowing down the renderer.</description>
    </item>
    
    <item>
      <title>Weekend raytracing with wgpu, part 1</title>
      <link>https://nelari.us/post/weekend_raytracing_with_wgpu_1/</link>
      <pubDate>Sun, 07 May 2023 06:43:00 +0300</pubDate>
      
      <guid>https://nelari.us/post/weekend_raytracing_with_wgpu_1/</guid>
      <description>Peter Shirley&amp;rsquo;s book Raytracing In One Weekend is a great way to kickstart your own path tracer. The book gives just enough information to get spheres rendered to your screen, minimizing the amount of time spent studying theory.
I wrote a straightforward implementation of the book’s renderer using Rust many years ago. Recently, I decided to go the extra mile and port the code to the GPU, using the wgpu crate.</description>
    </item>
    
    <item>
      <title>Writing a small ray tracer in Rust and Zig</title>
      <link>https://nelari.us/post/raytracer_with_rust_and_zig/</link>
      <pubDate>Thu, 27 Jun 2019 20:00:00 +0200</pubDate>
      
      <guid>https://nelari.us/post/raytracer_with_rust_and_zig/</guid>
      <description>I spend most of my programming time writing C++. And like many other C++ programmers, I&amp;rsquo;ve shot myself in the foot countless times with a feature I didn&amp;rsquo;t fully grok. And I&amp;rsquo;ve spent enormous amounts of time trying to understand the language. Like many other C++ developers in this position, I find myself frequently daydreaming about switching to another more modern and easily understood language.
The two languages that I spent most of my time daydreaming about writing code in are Rust and Zig.</description>
    </item>
    
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My thought repository</title>
    <link>https://nelari.us/post/</link>
    <description>Recent content in Posts on My thought repository</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 27 Jun 2019 20:00:00 +0200</lastBuildDate>
    
	<atom:link href="https://nelari.us/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Writing a small ray tracer in Rust and Zig</title>
      <link>https://nelari.us/post/raytracer_with_rust_and_zig/</link>
      <pubDate>Thu, 27 Jun 2019 20:00:00 +0200</pubDate>
      
      <guid>https://nelari.us/post/raytracer_with_rust_and_zig/</guid>
      <description>I spend most of my programming time writing C++. And like many other C++ programmers, I&amp;rsquo;ve shot myself in the foot countless times with a feature I didn&amp;rsquo;t fully grok. And I&amp;rsquo;ve spent enormous amounts of time trying to understand the language. Like many other C++ developers in this position, I find myself frequently daydreaming about switching to another more modern and easily understood language.
The two languages that I spent most of my time daydreaming about writing code in are Rust and Zig.</description>
    </item>
    
    <item>
      <title>imnodes: writing an immediate mode node editor library</title>
      <link>https://nelari.us/post/imnodes/</link>
      <pubDate>Sun, 24 Mar 2019 08:22:27 +0200</pubDate>
      
      <guid>https://nelari.us/post/imnodes/</guid>
      <description>Node editors are one of the more discussed use cases for the dear imgui UI library, and there are lots of gists as well as fully-fledged implementations for them on Github. If you want to implement your own node editor, you can get cracking! However, my pet peeve with the available samples and implementations is that they often aren&amp;rsquo;t immediate mode and don&amp;rsquo;t obey dear imgui&amp;rsquo;s philosophy of being lightweight and dependency free.</description>
    </item>
    
    <item>
      <title>Implementing simple translation and rotation gizmos</title>
      <link>https://nelari.us/post/gizmos/</link>
      <pubDate>Fri, 06 Apr 2018 16:17:29 +0200</pubDate>
      
      <guid>https://nelari.us/post/gizmos/</guid>
      <description>Fed up with entering numbers manually via the UI for each game object transform in my home-made game engine, I wanted to integrate a gizmo tool. Gizmos, at least in the context of game engine editors, are little 3d tools that you can use to manipulate objects in 3d space. While there are a few easy-ish-to-integrate transform gizmo libraries on github, I was not completely happy with them. The interface of tinygizmo is nice, but it intersects camera rays with the triangle meshes of the primitive.</description>
    </item>
    
    <item>
      <title>Embedding Wren in C&#43;&#43;, part 2</title>
      <link>https://nelari.us/post/wren-embedding-2/</link>
      <pubDate>Fri, 06 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nelari.us/post/wren-embedding-2/</guid>
      <description>You can read part 1 here.
Writing you own Wren bindings gives you full control over how your code interfaces with Wren. However, manually implementing the binding code for a large C++-Wren interface can be somewhat time consuming, especially when changes are made to the interface over time. Wren++ is a small C++ library that aims to automate most code binding tasks with a minimal runtime overhead. Like Wren itself, Wren++ aims to be simple and minimalistic to use.</description>
    </item>
    
    <item>
      <title>Embedding Wren in C&#43;&#43;, part 1</title>
      <link>https://nelari.us/post/wren-embedding-1/</link>
      <pubDate>Thu, 05 May 2016 00:00:00 +0000</pubDate>
      
      <guid>https://nelari.us/post/wren-embedding-1/</guid>
      <description>Wren is a small, fast, class-based scripting language designed to be easily embeddable in a host application. As such, it fills very much the same niche as Lua. Why would you choose Wren over Lua in your application? It boils mostly down to stylistic preferences. Wren is very class oriented, and adheres to the curly-brace style tradition, in contrast to Lua&amp;rsquo;s begin...end blocks. If one of the first things you always did in your Lua projects was design a class model, then Wren might be worth checking out.</description>
    </item>
    
    <item>
      <title>Placing an arbitrary number of function calls into a function argument list using templates</title>
      <link>https://nelari.us/post/template-function-args/</link>
      <pubDate>Mon, 31 Aug 2015 00:00:00 +0000</pubDate>
      
      <guid>https://nelari.us/post/template-function-args/</guid>
      <description>While I was trying to generate code to bind C++ to a scripting language, I discovered that C++ templates, in their current modern form, are not as scary as I used to think they were. Here are a few useful things that I discovered.
First, in toy form, the problem that I was trying to solve. Suppose I have a free function that I want to bind to a virtual machine.</description>
    </item>
    
  </channel>
</rss>